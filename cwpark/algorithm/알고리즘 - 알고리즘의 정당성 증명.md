# 알고리즘 - 알고리즘의 정당성 증명

우리가 알고리즘을 풀 때 모든 입력에 대해 알고리즘이 정확하게 동작한다는 사실을 어떻게 증명할까?

단위테스트를 사용한다?

단위 테스트를 이용하여 여러 입력에 대해 프로그램의 결과를 점검해 볼수 있다.

하지만, 알고리즘이 존재 가능한 모든 입력에 대해 정확히 동작한다는 보장을 할 수 없다.

알고리즘의 정확한 증명을 위해서는 **수학적 기법**을 사용해야 한다.

알고리즘의 증명을 왜 공부해야할까?

우리는 증명을 통해 알고리즘을 유도하는 데 결정적인 통찰을 얻을 수 있기 때문이다.

또한, 다른 알고리즘의 증명을 익혀서 자신이 설계한 알고리즘의 정당성을 쉽게 증명할 수 있다.

## 수학적 귀납법

수학적 귀납법(mathematical induction)은 반복적인 구조를 갖는 명제들을 증명하는 데 유용하게 사용되는 증명 기법이다.

예를 들어, 100개의 도미노가 가지런히 놓여져 있다고 상상하자. 그리고 다음 두 가지 사실을 가정하자.

- 첫 번째 도미노는 직접 손으로 밀어서 쓰러뜨린다.
- 한 도미노가 쓰러지면 다음 도미노 역시 반드시 쓰러진다.

이 두 가지 사실을 토해서 마지막 도미노 또한 쓰러진다는 것을 알 수 있다.

귀납법 증명을 하기 위해선 다음 **3가지 방법**을 사용한다.

1. 단계 나누기

증명하고 싶은 사실을 여러 단계로 나눈다.

ex) 100개의 도미노를 도미노 하나씩으로 나눈다.

1. 첫 단계 증명

첫 번째 행위(단계)에서 증명하고 싶은 내용이 성립하는 지를 보여준다.

ex) 첫 번째 도미노가 넘어진다.

1. 귀납 증명

한 단계에서 다음 단계로 넘어갈 때에도 증명이 성립함을 보여준다.

ex) 한 도미노가 쓰러지면 다음 도미노는 반드시 쓰러짐을 증명한다.

사다리 게임을 통해 귀납법 증명을 연습해보자.

사디리 게임은 항상 맨 위의 출발점 하나와 맨 아래 도착점 하나가 언제나 1:1 대응이 된다.

어떻게 이것이 가능할까를 귀납법을 통해 증명하는 것이다.

1. 단계 나누기

가장 첫 시작은 1:1 대응이 되어 있는 상태의 N개의 세로줄에서 시작한다.

원하는 사다리 형태가 만들어질 때 까지 가로줄을 하나 씩 긋는 것이 한 단계다.

다시 말해, 가로 줄 하나를 긋는 것을 한 단계로 본다.

1. 첫 단계 증명

가로 줄이 하나도 그어지지 않은 N 개의 세로줄에서 항상 맨 위 선택지와 맨 아래 선택지가 1:1 대응이 된다.

아래의 그림과 같다.

```java
O   V   U   X
|   |   |   |
O   V   U   X
|   |   |   |
O   V   U   X
|   |   |   |
O   V   U   X
|   |   |   |
O   V   U   X
```

1. 귀납 증명

가로줄을 그어서 두 개의 세로줄을 연결 하자.

이 때 두 세로줄의 결과를 서로 뒤바뀐다.

두 세로줄의 결과가 바뀌어도 1:1 대응은 변하지 않는다.

아래의 그림에서는 위에서 두 번째 O와 V가 서로 결과를 바꾸었다.

```java
O   V   U   X
|   |   |   |
O - V   U   X
|   |   |   |
O   V   U   X
|   |   |   |
O   V   U   X
|   |   |   |
O   V   U   X
```

## 반복문 불변식

대부분의 알고리즘은 어떠한 형태로든 반복적이다.

귀납법을 이용한 알고리즘 정당성 증명시에 반복문 불변식(loop invariant)를 주로 사용한다.

반복문 불변식이란 반복문 내용이 한 번 실행될 때마다 중간 결과가 우리가 원하는 답으로 가는 길 위에 있는지를 확인하는 조건이다.

불변식을 사용하여 반복문의 정당성을 다음과 같이 증명할 수 있다.

1. 반복문 진입시에 불변식이 성립함을 보여준다.
2. 반복문 내용이 불변식을 유지함을 보인다. 즉, 하나의 반복문 내용이 시작할 때부터 끝날 때 까지 불변식이 성립함을 보여준다.
3. 반복문 종료시에 불변식이 성립하면 정답을 구했음을 보여준다.

예를 들어, while 문에서 실제 불변식이 성립함을 보여야 하는 위치는 다음과 같다.

```java
// (*) 불변식은 여기에서 성립해야 한다.
while (조건) {
 // 반복문 내용 시작
 // 반복문 내용 끝
 // (**) 불변식은 여기에서도 성립해야 한다.
}
```

## 이진 탐색의 반복문 불변식

```java
// 전제조건: a는 오름차순으로 정렬되야 한다.
// 결과: a[i-1] < x <= a[i] 인 i를 반환한다.
// 이 떄, a[-1] = 음의 무한대, a[n] = 양의 무한대로 가정한다.
int binsearch(int[] a, int x) {
    int n = a.length;
    int lo = -1;
    int hi = n;
    // 반복문 불변식 1: lo < hi
    // 반복문 불변식 2: a[lo] < x <= a[hi]
    // (*) 반복문 불변식은 여기에서 성립해야 한다.
    while (lo + 1 < hi) {
        int mid = (lo + hi) / 2;
        if (a[mid] < x) {
            lo = mid;
        } else {
            hi = mid;
        }
        // (**) 반복문 불변식은 여기서도 성립해야 한다.
    }
    return hi;
}
```

이진 탐색의 while 문은 두 개의 불변식을 유지한다.

1. lo < hi
2. a[lo] < x ≤ a[hi]

1. 초기조건

while문이 시작하면 lo와 hi는 초기값 -1과 n이다.

만약 n=0 이면, while 문을 건너뛰므로 불변식 1은 항상 성립한다.

우리는 a[-1] = 음의 무한대, a[n] = 양의 무한대로 가정했으므로, 불변식 2 또한 성립한다.

1. 유지조건(while 문 내부에서 불변식을 유지하는가)
- a[mid] < x 인 경우
    - 반복문을 시작할 때 x ≤ a[hi] 는 이미 참이다.
- x ≤ a[mid] 인 경우
    - a[lo] < x < a[hi] 가 참임을 증명했다.
    - hi 대신, mid를 대입해도 불변식 2는 성립한다.
    

---

알고리즘 문제 해결 전략. 2012. 구종만. 인사이트.