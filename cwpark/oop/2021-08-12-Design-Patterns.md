# 디자인패턴은 어떻게 탄생하였나

임백준님의 칼럼을 요약한 정리 글입니다. https://zdnet.co.kr/view/?no=00000039131344



## 디자인 패턴의 시작

**객체지향의 창시자, 와드 커밍햄과 켄트 벡**은 1987년에 소프트웨어를 이용하게 될 사용자들이 직접 설계를 끝내도록 맡겼다. 

이 때 커닝험과 벡은 당시 사용중인 객체지향인 언어인 스몰토크에 익숙하지 않은 사용자들이 잘못된 설계를 하는 것을 방지하는 것을 고민했다.

그들은 스몰토크 언어를 이용한 설계에서의 몇 가지 핵심적인 내용을 간추린 **‘패턴(pattern)’**을 정리해서 교육시켰고 패턴의 중요성을 깨달았다.

1987년에 열린 OOPSLA(Object-Oriented Programming, Systems, Languages & Applications) 컨퍼런스에서 디자인 패턴을 소개하였다.

하지만 커닝험과 벡의 패턴은 아이디어 수준에 머물렀으며 구체적인 정리에 이르지는 못했다.



## 네 명의 일당들

이클립스 프로젝트 참여자로도 유명한 에리히 감마는 자신의 논문을 정리하는 과정에서 객체지향 언어로 객체를 설계할 때 특정한 패턴을 나타내면서 반복되는 ‘무엇’이 존재한다는 점을 분명히 인식했다. 

하지만 그 ‘무엇’을 다른 사람에게 전달할 ‘어휘’ 혹은 ‘의사소통’의 방법을 구체적으로 정립하지 않았다.

1991년에 개최된 OOPSLA에는 훗날 ‘네 명의 일당들(Gang of Four)’라는 별칭으로 불리게 되는 에리히 감마, 리처드 햄(Richard Helm), 랄프 존슨(Ralph Johnson), 존 블리시데스(John Vlissides)가 한 자리에 모이게 되었다. 

이 네 명이 여러 개의 패턴을 집대성해서 저술한 하나의 책이 탄생되었다. 

이 책의 이름이 **“디자인 패턴 : 재사용 가능한 객체지향 소프트웨어의 요소들(Design Patterns: Elements of Reusable Object-Oriented Software]” **이다.

객체지향 코드를 유려하게 작성하고 싶은 프로그래머라면 반드시 읽어봐야할 책이다.



## 건축, 패턴, 프로그래밍

> “각각의 패턴은 우리를 둘러싸고 있는 환경에서 반복적으로 나타나는 특정한 문제와 그에 대한 해결책을 설명한다. 그리고 그 해결책은 계속 사용될 수 있기 때문에 동일한 과정을 반복할 필요가 없다.” -  크리스토퍼 알렉산더

사실 소프트웨어 설계에서 나타나는 패턴이라는 개념은 알렉산더가 ‘건축’ 분야에서 정립한 개념을 빌려온 것이다.

프로그래밍 세계에서 패턴의 개념을 정립한 사람들은 건축 설계에 몰두했던 알렉산더의 저술에서 영감을 받았다. 

위에 인용한 패턴의 정의는 컴퓨터 프로그래밍이 아니라 건축과 관련이 있는 것이었지만 어떤 대상을 새롭게 디자인하는 과정 일반에 적용되는 보편적인 방법론을 가리키고 있기 때문에 소프트웨어 설계의 과정을 포함했다. 

‘네 명의 일당’은 소프트웨어 설계 패턴을 다음과 같이 정의했다. 

>  “설계 패턴은 객체지향 시스템 안에서 반복해서 등장하는 설계와 관련된 문제를 해결하기 위한 일반적인 기법에 이름을 붙이고, 동기를 부여하고, 설명을 한다. 그것은 문제를, 해결책을, 그리고 그 해결책을 언제 적용해야 하는지, 적용한 결과는 무엇인지 등을 설명한다. 그것은 또한 실질적인 구현에 대한 힌트와 예제도 제공한다. 해결책은 대개 문제를 해결하기 위해서 필요한 객체와 클래스를 일반적인 방식으로 배치한다. 해결책은 주어진 문제를 특정한 문맥(context) 안에서 해결하기 위해서 다듬어지고 구현된다.”

패턴을 익히는 것은 마치 바둑에서 ‘정석(定石)’을 익히는 것과 같아서 패턴의 내용이나 이름을 ‘암기’하는 것은 아무런 의미가 없다. 

‘네 명의 일당’이 밝힌 바와 같이 각각의 패턴이 필요한 동기, 그 패턴이 제공하는 해결책을 사용해야 할 시점, 그리고 그 해결책을 사용한 결과 등을 충분히 이해하는 것이 핵심이다. 

그렇지만 프로그래머를 채용하기 위한 면접 과정에서 설계 패턴에 대한 질문을 던지면 머리 속에 암기하고 있는 패턴의 이름을 앵무새처럼 이야기하는 사람들을 종종 만나게 된다. 

다시 한 번 이야기하지만 중요한 것은 패턴의 ‘이름’이 아니라 그 이름이 담고 있는 ‘문맥’이다. 

(임백준님은 칼럼에서 '내용(Content)'으로 표현했지만, '문맥(Context)'이 더 어울리는 용어일 것 같습니다.)



## 패턴의 완성

패턴은 ‘생성적(creational)’, ‘구조적(structural)’, 그리고 ‘행위적(behavioral)’이라는 세 범주로 구분된다.

싱글턴 패턴이 인스턴스의 수를 하나로 제한하는 것처럼 패턴은 저마다의 목적을 가지고 만들어졌다.

소프트웨어를 설계하는 프로그래머들은 의식적이든 아니든 패턴의 도움을 받으면서 복잡하고 정교한 객체의 건축물을 완성해왔다.

커닝험과 켄이 패턴의 개념을 내놓은 이후로 패턴은 프로그래머에겐 일종의 의례가 되었다.

하지만 객체가 모든 상황을 구원해주지 못하는 것처럼 패턴 역시 프로그래머가 언제든 가져다 쓸 수 있는 만병통치약은 아니다. 

객체의 설계든, 정교한 알고리즘의 작성이든, 그것은 오직 프로그래머 본인의 힘으로 해야 하는 일이다.

프로그램의 ‘완성도’와 ‘미학’은 패턴이 해결해주지 못한다. 

그 패턴을 이용하는 프로그래머에게 달려있다.

