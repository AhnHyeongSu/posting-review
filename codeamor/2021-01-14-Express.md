# Express 

Node.js 기반으로 서버를 개발한다는 것은 자유도가 높고 무한한 확장 가능성을 이야기합니다. 
Server-side Framework 들이 무수히 많기 때문입니다. 

다양한 노드기반 JavaScript 패키지들 중 
**Express** 에 대해서 다뤄보도록 하겠습니다.

<br>

# 만약 Express 가 없다면?

---

Express 가 없다면 어떻게 서버개발을 해야하는지 살펴보겠습니다. 

Express 는 웹서버를 만들 때 편리한 기능을 제공하는 프레임워크 입니다.

Express 가 없다면 오로지 Node.js 의 내장모듈인 http 를 사용해서 서버를 생성하고 http 요청을 처리하는 함수를 구현해야 합니다. 

- **withoutExpress.js**

```jsx
const http = require('http') // 1

const server = http.createServer((req, res) => { // 2
  console.log('request received')

  res.setHeader('Content-Type', 'application/json') // 3
  res.end(JSON.stringify({ message: "http server without express" })) // 4
});

server.listen(3000, () => { console.log('server is learning on PORT 3000')}) // 5
```

1. Node.js 내장 `http` 모듈을 가져와서 아래에서 사용할 수 있도록 변수에 담는 코드입니다.
2. `http.createServer` 는 콜백함수를 받습니다. 이 콜백함수의 첫번째 인자는 http request 의 정보가 담겨있는 객체, 두번째 인자는 http response 객체입니다. 서버에 요청이 들어오면 이 콜백함수가 실행되는 꼴입니다.
3. 요청에 대한 응답의 header 를 `application/json` 형태로 세팅합니다.
4. `res.end` 함수를 통해서 요청에 대한 응답을 마무리 합니다. 이 함수의 인자로 넘겨주는 값이 클라이언트가 받는 응답이 됩니다.
5. `server` 는 앞서 생성한 서버를 의미하고 이 서버 객체의 `listen` 함수는 인자로 포트 번호와 콜백함수를 받습니다. 포트번호로 서버를 연다는 의미이며, 서버가 실행될 때의 로직을 콜백함수 안에서 처리할 수 있습니다. 보통 서버가 켜져있다는 로그 메시지를 남깁니다.

해당 파일이 있는 현재 디렉토리에서 다음 명령어를 입력합니다.

```bash
node withoutExpress.js
```

아래와 같은 결과화면이 뜬다면 성공적으로 첫 노드 서버를 개설한 것 입니다.

![image](https://user-images.githubusercontent.com/65898889/104606927-a0b8a900-56c3-11eb-8628-fd190167195f.png)

서버를 열었으니 요청을 보내고 응답을 받아보도록 하겠습니다. 

```bash
# httpie 라는 터미널 전용 http client 프로그램이 설치되어있어야 합니다. 
# mac 환경
brew install httpie
# ubuntu 환경 
apt-get install httpie

# 성공적으로 설치가 끝난후 아래 명령어를 터미널 창에서 입력해 봅니다.
http localhost:3000 
```

아래와 같은 응답이 뜬다면 여러분의 서버는 성공적으로 작동하고 있습니다.

![image](https://user-images.githubusercontent.com/65898889/104606746-6c44ed00-56c3-11eb-8c06-d9a2aa1fb319.png)


유저를 회원가입도 시켜야 하고, 로그인도 처리해야 하며, 프론트엔드 측에서 요구하는 상품에 대한 정보도 응답으로 보내줘야 하는 경우도 있을 것입니다.

이렇게 해당 자원에 대해 다른 함수(로직)을 실행하도록 하는 것을 **라우팅** 이라고 합니다.

위의 상황에 대해서 의사코드를 작성하면 다음과 같이 될 겁니다. 

- **withoutExpress.js**

```jsx
const http = require('http')
const { sendPosts } = require('./sendPosts')

const server = http.createServer((req, res) => {
  const { url, method } = req
  res.setHeader('Content-Type', 'application/json')

  if (url === '/') res.end(JSON.stringify({ message: '/ endpoint' }))
  if (url === '/signup' && method === 'POST') handleSignUp(req, res)
  if (url === '/login' && method === 'POST') handleLogin(req, res)
  if (url === '/products' && method === 'GET') sendPosts(res)

  res.end(JSON.stringify({ message: 'this response answers to every request' }))
})

server.listen(3000, () => { console.log('server is listening on PORT 3000')})
```

- **sendPosts.js**

```jsx
const sendPosts = (res) => {
  res.end(
	JSON.stringify({ 
		products: [{
	      id: 1,
	      title: "node",
	      description: "node.js is awesome"
	    }, {
	      id: 2,
	      title: "express",
	      description: "express is a server-side framework for node.js"
	    }
	  ]
	}))
}

module.exports = { sendPosts } // withoutExpress.js 에서 사용하기 위해 모듈로 내보낸다.
```

보이는 바와 같이 라우팅을 직접 request 객체에서 url과 method 에 따라서 조건문으로 분기해서 다른 로직(`handleSignUp, handleLogin, sendPosts`)을 처리해 주어야 합니다. 

여기서 끝이 아니라 점점 더 앱의 규모가 커지게 된다면
서버를 실행하는 함수 안에서 수많은 조건문과 수많은 로직을 모듈화 하는데 큰 공을 들이게 됩니다. 

이런 불편함을 해소하기 위해서 탄생한 프레임워크가 Express 입니다.
<br>

# Express란?

---

Express 의 공식사이트에 따르면 다음과 같이 정의되어 있습니다.

> *Express is fast, unopinionated, minimalist web framework for node.js.*

실제로 Express 는 노드개발자들이 많이 채택하는 프레임워크 입니다. 
위에서 언급했던 **라우팅** 과 **로직의** **모듈화** 를 위해 사용 됩니다.

Express 는 더욱더 읽기 쉽고 유연하고 지속가능한 백엔드 앱을 개발할 수 있도록 돕는 프레임워크 입니다.

위에서 Express 없이 작성한 세가지 엔드포인트를 Express 를 통해 구현한다면 다음과 같은 코드를 작성할 수 있습니다. 

- **routing.js**

```jsx
const http = require('http')
const express = require('express')
const { sendPosts } = require('./sendPosts')

const app = express()

app.get('/', (req, res) => {
  res.json({ message: '/ endpoint' })
})

app.post('/signup', handleSignUp) // 첫번째 인자에는 endpoint url 을 기입하고,
app.post('/login', handleLogin) // 각각의 요청에 대해 핸들링 하는 함수를 두번째 인자로 넣습니다.
app.get('/products', sendPosts)

const server = http.createServer(app)

server.listen(3000, () => {
  console.log('server is listening on PORT 3000')
})
```

**app.method('path', handler function)**

코드에서도 볼 수 있듯, 
Express 모듈을 임포트 한 후 함수를 실행해서 app 이란 변수에 담는 것이 **컨벤션** 입니다.
클라이언트의 요청을 처리하는 http server application 이라고 볼 수 있는 것이죠. 

이 앱을 사용하는 방법은 다음과 같습니다.

1. 요청을 받을 http method로 함수를 app 에 붙인다.
2. 요청을 받을 endpoint url 을 string 으로 첫번째 인자에 넣는다.
3. 두번째 인자는 요청과 응답을 인자로 받는 콜백함수이다. 
**즉, 각각의 메소드와 엔드포인트에 대해 처리하는(핸들링) 함수가 된다.** 
- **sendPosts.js**

```jsx
const sendPosts = (req, res) => {
  res.json({ // 위에서 작성한 sendPosts 함수와 비교했을 때,
  // express 덕분에 JSON.stringify 함수를 사용할 필요없이
  // response 객체의 json 메소드를 활용합니다.
    products: [
      {
        id: 1,
        title: 'node',
        description: 'node.js is awesome',
      },
      {
        id: 2,
        title: 'express',
        description: 'express is a server-side framework for node.js',
      },
    ],
  })
}

module.exports = { sendPosts } // routing.js 에서 사용하기 위해 모듈로 내보낸다.
```

Express 없이 서버를 구현한 코드와 비교해 봤을 때, 아직은 크게 와닿지 않을 수도 있지만

- 조건문으로 **라우팅**을 처리했던 것이 간편 해 졌고
- 각각의 요청을 처리하는 **함수의 분리**로 인해

직관적으로 코드를 설계할 수 있다는 장점을 가지고 있습니다.