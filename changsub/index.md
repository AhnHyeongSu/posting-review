# \<JPA\> 영속성 관리 - 내부 동작 방식
## 영속성 컨텍스트
- **“Entity”를 영구 저장하는 환경**이라는 뜻이다.
- `EntityManager.persist(entity)`를 통해서 엔티티를 영속성 컨텍스트에 저장한다.(중요한 포인트는 연동된 DB에 저장하지 않는다는 것이다)
- EntityManager를 통해서 영속성 컨텍스트에 접근 할 수 있다.
- 아래 그림과 같이 J2SE환경에서는 서로 1대1관계를 맺고 있다.
![](Screen%20Shot%202021-10-20%20at%2011.06.09%20PM.png)

## 엔티티의 생명주기
- 비영속 : 엔티티를 생성만 한 상태
- 영속 : em.persist()를 통해 영속성 컨텍스트에 엔티티를 넣은 상태(앞서 언급한 것 처럼 DB에 저장이 되지 않으며, **즉 쿼리가 나가지 않음**)
- 준영속 : em.detach()를 통해 영속성 컨텍스트에서 엔티티를 분리시킨 상태
- 삭제 : em.remove()를 통해 DB에 저장된 엔티티까지 삭제시킨 상태
![](Screen%20Shot%202021-10-20%20at%2011.15.28%20PM.png)

> 그러면 DB에 entity를 저장하는 쿼리는 언제 발생하는걸까? 

## 영속성 컨텍스트의 기능
### 1차 캐시
- 영속성 컨테스트는 아래와 같이 1차 캐시 구조를 가진다.
- `em.find()`를 통해서 엔티티를 조회할 경우, 우선적으로 1차 캐시부터 먼저 탐색한다.
- 1차 캐시에서 탐색 후, 없는경우에만 **직접 DB로 쿼리를 날려** 해당되는 엔티티를 가져와서 1차캐시에 저장하고 나서, 반환해준다.
![](Screen%20Shot%202021-10-20%20at%2011.16.33%20PM.png)

### 영속 엔티티의 동일성 비교(== 비교)
- 쉽게 말해서 아래와 같은 코드를 실행하면 동일하다고 true가 출력된다.
```java
Member a = em.find(Member.class, "member1");
Member b = em.find(Member.class, "member1");
System.out.println(a == b);
```
- 메모리 주소 연산을 하듯이, 동일한 1차캐시에 저장되어 있기에 위와같은 결과가 도출된다.

### 쓰기 지연
- 위에서 언급된 질문에 대한 대답을 해줄 수 있는 기능이다.
- `em.persist(memberA)`, `em.persist(memberB)`를 한 경우 아래의 그림과 같이 영속성 컨텍스트가 동작한다.
- 먼저 영속성 컨텍스트에 해당 엔티티를 생성하고 위의 언급된 1차캐시에 저장한다.
- 이후 Insert 문을 ‘쓰기 지연 SQL 저장소’에 넣어둔다.
- 해당 저장소에 저장된 쿼리는 어떠한 명령어가 들어오기 전까지 DB로 보내지지 않는다.
![](Screen%20Shot%202021-10-20%20at%2011.58.06%20PM.png)![](Screen%20Shot%202021-10-20%20at%2011.58.17%20PM.png)
- 모여있는 쿼리들은 `transaction.commit()`을 통해서 DB로 보내진다.
- 커밋을 실행하면 아래와 같은 동작방식으로 DB에 쿼리가 날라간다.
![](Screen%20Shot%202021-10-21%20at%2012.01.08%20AM.png)

### 변경 감지
- 