# IoC(Inversion of Control)
- 제어의 역전?
  - 나 자신이 제어권을 가지고 있지 x, 나 이외의 누군가가 의존성에 대한 제어권을 가지고 있다.
    - 어떤 객체가 사용하는 의존 객체를 직접 만들어서 사용하는게 아니라 주입 받아서 사용하는 것을 말한다.

## 일반적인 의존성에 대한 제어권
> "내가 쓸 놈은 내가 만들어 쓸게"
```java
class OwnerController {
    private OwnerRepository repository = new OwnerRepository();
}
```
- OwnerController가 OwnerRepository를 생성한다. 
  - 의존성에 대한 제어권 => 본인

## IoC
> "내가 쓸 놈은 이 놈인데... 누군가 알아서 주겠지"
```java
class OwnerController {
    private OwnerRepository repo;

    public OwnerController (OwnerRepository repo) {
        this.repo = repo;
    }
}
```
- OwnerController가 생성될 때 누군가가 OwnerRepository 객체를 준다.
  - 의존성에 대한 제어권 => 누군가

```java
class OwnerControllerTest {
    public void create() {
        OwnerRepository repo = new OwnerRepository ();
        OwnerController controller = new OwnerController(repo);
    }
}
```
- OwnerControllerTest가 OwnerRepository를 생성해서 이를 OwnerController에 주입해준다.
  - 의존성에 대한 제어권 => OwnerControllerTest

# IoC 컨테이너
- `AppicationContext`
  - `BeanFactory`를 상속받았다.
  - `MessageSource` : 메시지 소스 처리 기능(i18n)
  - 이벤트 발행 기능
  - `ResourceLoader` : 리소스 로딩 기능
  - 등등
- IoC 컨테이너는 빈(bean)을 만들고 빈(bean)들의 의존성을 관리해준다.
  - OwnerController(@Controller), OwnerRepository(@Repository)는 IoC 컨테이너에서 관리하는 빈(bean)이다.
  - Owner는 빈(bean)이 아니다.

### 빈 설정
- 이름 또는 ID
- 타입
- 스코프

# Bean(빈)
스프링 IoC 컨테이너가 관리하는 객체
- 장점
  - 의존성 관리
  - 스코프
    - 싱글톤 : 하나
    - 프로토타입 : 매번 다른 객체
  - 라이프사이클 인터페이스

## 빈을 등록하는 방법
- Component Scanning
  - `@Component` : 이 애노테이션이 있으면 스프링 빈으로 자동 등록된다.
    - `@Repository`
    - `@Service`
    - `@Controller`
- 직접 xml이나 자바 설정 파일에 등록
  - xml 설정 방식은 최근에는 잘 사용하지 않는다.
  - 자바 설정파일에서 빈 등록시 `@Bean` 어노테이션을 붙여야한다.
    - `@Bean`은 `@Configuration` 안에 정의해야 한다.


> 스프링은 스프링 IoC 컨테이너에 스프링 빈을 등록할 때, 기본으로 싱글톤으로 등록한다.(유일하게 하나만 등록해서 공유) 따라서 같은 스프링 빈이면 모두 같은 인스턴스다. 설정으로 싱글톤이 아니게 설정할 수 있지만, 특별한 경우를 제외하면 대부분 싱글톤을 사용한다.

### Component Scan 방식으로 스프링 빈(MemberService) 등록
```java
@Service 
public class MemberService {
    private final MemberRepository memberRepository;

    @Autowired
    public MemberService(MemberRepository memberRepository) {
        this.memberRepository = memberRepository;
    }
}
```
### 자바 설정 파일로 스프링 빈(MemberService) 등록
```java
@Configuration
public class SpringConfig {

    @Bean
    public MemberService memberService() {
        return new MemberService(memberRepository());
    }

    @Bean
    public MemberRepository memberRepository() {
        return new MemoryMemberRepository();
    }
}
```

> 실무에서는 주로 정형화된 컨트롤러, 서비스, 리포지토리 같은 코드는 컴포넌트 스캔을 사용한다. 
> 정형화되지 않거나, 상황에 따라 구현 클래스를 변경해야 하면 설정을 통해 스프링 빈으로 등록한다.

## 빈을 가져오는 방법
- `@Autowired` 또는 `@Inject`
  - `@Autowired` : 연관된 객체를 IoC 컨테이너에서 찾아서 넣어준다.
    - 객체 의존관계를 외부에서 넣어주는 것 -> **DI(Dependency Injection)**, 의존성 주입
- 또는 `ApplicationContext`에서 `getBean()`으로 직접 꺼낸다.

# DI(Dependency Injection)
어떤 빈에
- 1. 생성자가 **오직 하나**만 있고
- 2. 파라미터로 받는 타입(매개변수 타입)의 **빈이 존재**한다면
@Autowired 애노테이션을 생략해도 의존성을 주입해준다. (스프링 4.3)

```java
class OwnerController {
    private OwnerRepository repo;

    public OwnerController (OwnerRepository repo) {
        this.repo = repo;
    }
}
```
> @Autowired를 통한 DI는 스프링이 관리하는 객체(빈)에서만 동작한다. 스프링 빈으로 등록하지 않고 내가 직접 생성한 객체에서는 동작하지 않는다.

## @Autowired / @inject를 어디에 붙일까?
- 생성자
  - 이 클래스에 반드시 필요한 객체다 => 생성자
  - 의존관계가 실행중에 동적으로 변하는 경우는 거의 없으므로 **생성자 주입을 권장**한다.
- 필드
  - Setter가 없다 => 필드
- Setter
  - Setter가 있다 => Setter

# 참고자료
- 스프링 프레임워크 입문
- 스프링 입문 - 코드로 배우는 스프링 부트, 웹 MVC, DB 접근 기술



