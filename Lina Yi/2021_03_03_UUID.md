

현재 프로젝트에서 각각의 작업에 PK를 부여해야 하는데, PK를 Auto increment로 할 것인가? UUID 로 할 것인가 하는 고민에 빠짐



## UUID란?


- UUID(Universally Unique Identifier)의 약자

- 네트워크에서 id의 고유성(uniqueness)를 보장하고자 만든 국제 표준.

- UUID 표준에 따라 이름을 부여하면, 고유성을 완벽하게 보장할 수는 없지만 실제 사용상에서 중복될 가능성이 거의 없다고 인정되기 때문에 많이 사용되고 있음.


- 표준 형식에서 UUID는 32개의 16진수로 표현되며 총 36개 문자(32개 문자와 4개의 하이픈)로 된

8-4-4-4-12라는 5개의 그룹을 하이픈(-)으로 구분.
<hr/>

## 포맷

** ex) 6fee0f11-9c5e-4340-845c-34e6b5e6dd3b**


- 사용가능한 UUID의 갯수는 340,282,366,920,938,463,463,374,607,431,768,211,456개.

- 중복될 가능성이 거의 없음.

<hr/>


## 어디에서 만들었나?

- Open Software Foundation (OSF)에서 제정

- 소프트웨어 구축에 쓰이는 식별자 표준으로, 개방 소프트웨어 재단(OSF)이 분산 컴퓨팅 환경(DCE)의 일부로 표준화 함

<hr/>

## 종류

UUID의 버전은 5가지가 있음.

이 중 가장 많이 쓰이는 버전은 time stamp기반인 버전1과 랜덤 생성 기반인 버전4.


<hr/>

## 장점


1. 여러 테이블 혹은 여러 데이터베이스에서 공유하는 UUID를 생성, 관리 가능

(ex. 대형마트 E와 백화점 S를 하는 회사 A가 고객 계정 정보를 각자의 DB에 저장하는 경우)


2. URL에 노출되어도 상대적으로 보안에 좋음

(/user/1과 /user/1a16271ac7af48ed8bb1d4a65cdb421b의 차이)

<hr/>


## 단점

1. uuid를 쓸 경우 대개 유지보수성이 안 좋음 (데이터 확인 시 36글자 문자열을 복붙해야 함 vs 숫자 하나 입력)


2. 단순 계산으로 성능이 9배 나빠짐 (int 4byte, varchar(36) byte)

  (인덱스가 비대해져 메모리를 압박하게 됨)


3. 주소가 지저분해짐 (/user/1a16271ac7af48ed8bb1d4a65cdb421b ...)




### 참고 ) 글쓴이의 결론


둘 다 만들기.

pk는 AI로 냅두고 별도로 uuid_router_key라는 unique 인덱스를 만듬.

내부적으로 JOIN할 때는 AI로 조인하고, 외부적으로는 uuid_router_key로 접근.

모든 테이블에 만들 필요도 없고 외부로 통하면서 중요한 테이블에만 만들면 됨.

거기에 더해서, 축약, 숫자형 의사uuid를 이용하면 2번, 3번 단점도 꽤나 해소됨.순수 uuid가 꼭 필요한 게 아니라면.



### 참고자료


https://okky.kr/article/464366
https://medium.com/@jang.wangsu/ios-swift-uuid%EB%8A%94-%EC%96%B4%EB%96%A4-%EC%9B%90%EB%A6%AC%EB%A1%9C-%EB%A7%8C%EB%93%A4%EC%96%B4%EC%A7%80%EB%8A%94-%EA%B2%83%EC%9D%BC%EA%B9%8C-22ec9ff4e792
https://toma0912.tistory.com/19
https://velog.io/@ayokinya/uuid%EB%9E%80



﻿