
### 1. VIRT, RES 

- **VIRT: Virtual Image의 약자.**

- 모든 코드, data, 공유된 라이브러리, swap out된 페이지 전체를 이야기한다.

- 프로세스에 할당된 가상 메모리 전체.(SWAP + RES)

- **ES: Resident size의 약자.**

- 현재 프로세스가 사용중인 물리 메모리

- 실제로 메모리에 올려서 사용중인 물리 메모리

- swap되지 않은, 사용 중인 physical memory를 이야기 한다.



- **SWAP : 컴퓨터 메모리가 흘러 넘칠 때 댐의 역할을 함.**
- 메모리가 완전히 가득 차면 추가적으로 실행되는 프로그램은 메모리가 아닌 SWAP 파티션에서 실행됨. 메모리 공간이 가득 차서 부족할 때 프로그램 실행이 가능하도록 예비 공간의 역할을 함
 

- VIRT와 RES 값 차이가 크다는 것은 SWAP을 많이 사용한다는 의미
- swap을 많이 사용하는 것은 성능 이슈를 야기하므로 좋은 것은 아니다


### 2. VIRT와 RES 그리고 Memory Commit의 개념

그렇다면 왜 메모리는 VIRT와 RES로 구분되어 있을까? 둘다 프로세스가 사용하는 메모리를 표현하는 것이지만 차이점이 있다.

VIRT로 표현되는 가상 메모리는 **프로세스가 커널로부터 사용을 예약받는 메모리** 라고 생각할 수 있다.
프로세스는 malloc()과 같은 시스템콜로 **자신이 필요로 하는 메모리의 영역을 할당해줄 것을 요청** 한다.

이에 대해 커널은 가용한 공간이 있다면 성공 메세지와 함께 해당 프로세스가 사용할 수 있도록 **가상의 메모리 주소를 전달**해준다.

하지만 기억해야할 것은 이때에도 물리 메모리에 해당 영역이 할당된 상태는 아니라는 점이다.
이런 동작 방식을 Memory Commit이라고 한다.
(커널 파라미터 중에 vm.overcommit_memory를 통해서 동작 방식을 정의할 수 있음)

그 후 프로세스가 할당받은 메모리 영역에 **실제로 쓰기 작업을 하면 Page fault가 발생하며, 그제서야 커널은 실제 물리 메모리에 프로세스의 가상 메모리 공간을 매핑**한다.

이것은 Page Table이라고 불리는 커널의 전역 변수로 관리된다.
그리고 이렇게 **물리 메모리에 바인딩된 영역이 RES로 계산**된다.




- malloc 테스트 코드
```
#include <stdio.h>
#include <string.h>
#include <stdlib.h>

int main(){
   void *myblock = NULL;
   int count = 0;

  while(1){
    myblock = (void *) malloc(MEGABYTE);
    // malloc: 동적으로 메모리를 할당하는 함수
    if(!myblock){
        printf("Error!");
        break;
     }

          printf("Currently allocating %d MB\n", (++count)*MEGABYTE);
      memset(myblock, 1, MEGABYTE);
      // memset: 어떤 메모리의 시작점부터 연속된 범위를 어떤 값으로(바이트 단위) 
      모두 지정하고 싶을 때 사용하는 함수이다.

     sleep(1);
  }

  exit(0);
}
```


이 예제에서는 malloc()으로 메모리 영역을 요청한 후 아무것도 하지 않는다.

memset()함수를 주석처리한 후 이 예제를 실행하고, 터미널을 하나더 띄워서 top명령으로 해당 프로세스의 변화과정을 살펴보면,
시간이 지나면서 VIRT는 계속해서 높아지지만, RES는 늘어나지 않는 것을 볼 수 있다.


주석처리를 해제하고 돌려보면, 할당받은 메모리를 받은 순간에 바로 사용한다.

아까와는 다르게 RES영역이 VIRT영역의 늘어나는 비율과 비슷하게 늘어난다.

그렇기 때문에 메모리 사용과 관련하여 중요한 부분은 VIRT가 아니라 실제로 메모리를 쓰고 있는 RES임을 확인할 수 있다.

#### malloc()와 VIRT 증가 의문점 
VIRT는 malloc()등의 시스템 콜을 사용하면 늘어나게 되는데, 한도 끝도 없이 늘어나게 될까?
할당 받고 사용한 메모리는 RES 영역으로 계산이 되고, 이것은 물리 메모리와 관련이 있기 때문에 더이상 줄 수 있는 메모리 영역이 없다면 swap을 사용하거나 OOM으로 프로세스를 죽이는 방법 등으로 메모리를 확보하게 될 것이다.


그렇다면 VIRT와 같이 실제 사용하지 않는 영역의 경우에는 어떻게 될까?
대답은 그렇게 할 수도, 그렇게 하지 못하게 막을 수도 있다.

이 동작은 커널 파라미터 중 vm.overcommit_memory 파라미터에 의해 결정된다.

### Memory Commit

- 프로세스는 자신만의 작업 공간이 필요하고, 그 공간은 메모리에 존재한다.

- 프로세스가 커널에 필요한 만큼의 메모리를 요청(malloc()과 같은 시스템 콜을 통해)하면, 커널은 가용용량을 확인 후 프로세스에 사용 가능한 메모리 영역을 주고, 가상메모리 주소를 전달. 하지만 실제 물리 메모리에 할당하지 않음. 실제로 할당은 하지 않았지만, 해당 영역을 프로세스에 주었다는 것을 저장해둔다.

- 커널로부터 메모리를 할당 받고 메모리 주소를 전달받지만, 실제 물리메모리에 할당하지 않는 동작방식이 Memory commit


- 프로세스는 독립된 작업공간이 필요하기 때문에 Virtual memory 공간을 할당받고, 실제로 메모리에 쓰게될 때 물리 메모리에 할당하게 된다


- VIRT : 가상메모리는 프로세스가 커널로부터 사용을 예약받은 메모리


- 이 일련의 과정을 Memory Commit이라고 부른다.
그럼 왜 커널은 프로세스의 메모리 요청에 따라 즉시 할당하지 않고, Memory commit과 같은 기술을 써서 요청을 지연시키는 것일까?


#### Memory commit의 이유 
여러가지 이유가 있겠지만, 가장 큰 이유는 fork()와 같은, 새로운 프로세스를 만들기 위한 콜을 처리해야하기 때문이다.

모든 프로세스는 fork()를 통해서 만들어지기 때문에 부모와 자식 관계가 되고, 보통 부모 프로세스는 자식이 완료될 때까지 기다리게 된다.

fork()시스템 콜을 사용하면 커널은 현재 실행 중인 프로세스와 똑같은 프로세스를 하나더 만들게 되는데,

대부분은 **fork()후 exec() 시스템 콜을 통해서 전혀 다른 프로세스로 변한다. 따라서 이때 확보한 메모리 영역이 대부분 쓸모 없어질 수도 있다.
**
그래서 COW(Copy-On-Write)라는 기법을 통해서 복사된 메모리 영역에 실제 쓰기 작업이 발생한 후에야 실질적인 메모리 할당을 시작한다.

그리고 이런 작업을 지원하기 위해 Memory Commit이 필요하다.
만약 Memory Commit을 하지 않고 바로 할당한다면 COW와 같은 기술도 사용할 수 없기 때문이다.



참고자료:

https://sergeswin.com/1034/
https://aroundck.tistory.com/2646
https://chrisjune.github.io/kernel-02-top
https://jihooyim1.gitbooks.io/linuxbasic/content/contents/02.html
