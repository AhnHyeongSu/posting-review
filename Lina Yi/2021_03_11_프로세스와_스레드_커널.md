인터넷에서 프로그램을 다운로드받아 PC에 설치해 본 적이 있을 것이다. 

프로그램을 설치해서 아이콘을 더블클릭해서 시작하면 창이 뜬다.

다시 한번 프로그램 아이콘을 더블클릭하면 다른 별도의 창이 열릴 것이다. 이것이 프로세스나 스레드라고 불리는 것이다.


- 프로세스 및 스레드는 프로그램 실행 파일 자체가 아니라 **OS상에서 실행되서 어느 정도 독립성을 가지고 동작하는 것**임.


- 프로세스 및 스레드가 활동하려면 메모리 공간이 필요하다. 
이것은 커널에 의해 메모리상에 확보된다. 이 메모리 공간은 개인 공간이다.


![](https://images.velog.io/images/sandartchip/post/ee0dc559-96f3-40a2-8910-fd3e8a39e691/K1.jpg)

![](https://images.velog.io/images/sandartchip/post/3c1d6dc6-d35b-488e-a74c-c75e7d3baf93/K3.jpg)

- 먼저, 웹 서버를 보자. 'httpd 프로세스'라고 쓰여 있는 막대 인간이 프로세스다. 
그 주변을 감싸고 있는 하얀 공간이 있는데, 이것이 프로세스의 메모리 공간을 나타낸다. 


- AP서버도 보자. '스레드'라고 쓰여 있는 막대 인간이 쓰레드다. 
웹 서버와 달리 AP서버 상의 막대 인간은 하나의 메모리 공간을 공유하고 있다. 

이것이 프로세스와 스레드의 큰 차이점이다. 

- 프로세스는 **전용 메모리 공간을 이용해서 동작**한다. 

- 스레드는 **다른 스레드와 메모리 공간을 공유하고 있는 운명 공동체**다.


(예를 들면, 프로세스는 맞벌이 부부처럼 통장을 각자 관리하고 있는 형태다. 반면에 쓰레드는 아내가 남편의 부양 가족이 되는 모습이다. 자녀가 많아지면 부양가족이 늘어나지만, 하나의 통장으로 꾸려나가야 한다. 두 가족 모두 구조는 다르지만 생활한다는 목적은 같다. 프로세스와 스레드의 관계도 비슷하다.)


- 프로세스와 쓰레드 중에 어떤 것을 이용할지는 애플리케이션 개발자가 정한다. 이 때 각각의 특성을 이해하고 설계와 프로그래밍할 필요가 있다. 

예를 들어, 프로세스는 독자 메모리 공간을 가지기 때문에 생성 시 CPU 부하가 스레드와 비교해 높아진다.

- 때문에 멀티프로세스 애플리케이션에서는 프로세스 생성 부담을 낮추기 위해 미리 프로세스를 시작시켜 둔다. 
 

- 여러 개를 동시에 실행할 때의 프로세스와 스레드의 장단점을 간단히 정리해 보았다.

### <여러개 동시 실행 시에 프로세스와 스레드 장단점 비교>


**프로세스**
- 장점: 개별처리. 독립성이 높다 
- 단점: 생성 시 cpu 부하가 높다

**스레드** 
- 장점: 생성 시 부하가 낮다 
- 단점 : 메모리 공간을 공유하기 때문에 의도하지 않는 데이터 읽기/쓰기가 발생할 수 있다.

단, 프로세스가 메모리 공간을 공유할 수 없는 것은 아니다. 예를 들어, 오라클 DB에서는 여러 프로세스가 '공유 메모리공간'을 상호 이용할 수 있게 되어 있다.
 
![](https://images.velog.io/images/sandartchip/post/428a73bf-55f9-4e61-939c-7861b979672f/K2.jpg)

이와 별도로 프로세스별 독자 메모리 영역도 있어서 용도별로 나누어 사용하고 있다.

프로세스 간에 공유하고 싶은 데이터, 예를 들어 캐시로 저장하고 있는 데이터는 공유 메모리 상에 둔다.

한편, 프로세스 단독으로 이용하는 데이터, 예를 들어 자신이 계산할 결과는 전용 메모리에 둔다.

## OS 커널

![](https://images.velog.io/images/sandartchip/post/0e0840f4-e671-4905-8253-299462e7425a/KakaoTalk_20210311_233907714.jpg)
OS에서 커널은 심장이자 뇌이며 척수다.

커널이 OS의 본질이며, 나머지는 그저 덤일 뿐이라고 해도 과언이 아니다.

커널 자체가 OS의 '인프라'라고 생각하면 된다.

커널은 다양한 역할을 갖지만, 가장 중요한 것은 **'뒤에서 무슨 일이 일어나는지 은폐하면서도 편리한 인터페이스를 제공하는 것'**이다.

이렇듯 커널이 존재하기 때문에 개발자는 하드웨어나 다른 애플리케이션에 끼치는 영향을 의식하지 않고 애플리케이션을 만들 수 있다.

OS처리는 원칙적으로는 커널을 통해 이루어진다.

커널의 역할에는 여러가지가 있지만 여섯가지로 정리할 수 있다.

### 커널의 역할

#### 1. 시스템 콜 인터페이스
- **프로세스/스레드에서 커널로 연결**되는 인터페이스. 
- 디스크 상의 데이터를 읽고 싶거나 네트워크 통신을 하고 싶을 때 해당 시스템콜을 호출하면 기능을 이용 가능.
- 뒤에서 구체적으로 어떤 처리를 하고 있는지는 프로세스가 의식할 필요가 없다. 
- 디스크 읽기/쓰기나 네트워크를 통한 읽기/쓰기는 **프로세스 관점에서는 동일한 시스템 콜**이다.

#### 2. 프로세스 관리
- 이 기능이 없으면 OS가 성립되지 않기 때문에 **OS에 있어 가장 중요한 역할**
- OS상에서는 수십, 수백, 수천 개의 프로세스를 가동할 수 있다.
- 이에 비해 물리 서버의 CPU 코어 수는 많아야 수십 수백 개 정도 밖에 안 된다.
- **언제, 어떤 프로세스가 어느정도의 CPU 코어를 이용할 수 있는지, 처리 우선순위를 어떻게 결정할 것인지 등을 관리**하는 것이 이 기능의 역할.

#### 3. 메모리 관리
- 프로세스 관리는 CPU 코어를 고려했지만, 메모리 관리에서는 물리 메모리 공간의 최대치를 고려한다.
- 프로세스가 이용하는 독립 메모리 공간을 확보하거나 상호 간의 참조 영역을 지키기 위해 독립성을 관리하는 등의 메모리 관리 역할을 한다.
- 이 기능이 없다면 각 프로세스는 자신 이외의 프로세스가 사용하고 있는 메모리 영역 범위를 파악해야 하므로 해당 하드웨어의 신이 아닌 이상은 애플리케이션 개발이 매우 어렵다.

#### 4. 네트워크 스택
- 차후에 다룸..

#### 5. 파일 시스템 관리
- 파일 시스템은 OS의 기능의 하나로서 물리 디스크에 제공된 데이터를 관리하는 기능이다.
- 여러분이 일상에서 사용하는 '문서 파일'이나 '엑셀 파일'이 파일에 해당한다.
- 물리 디스크에 기록된 데이터는 '0101110...'과 같은 숫자 집합에 불과하다. 구분 표시도 없을 뿐더러 그대로 사용하기에는 매우 어려운 형태다.
- **파일 시스템 덕분에 애플리케이션은 '파일'이라는 단위로 데이터를 작성하거나 삭제할 수 있다.**

- 주요 관리 기능으로는 디렉토리(폴더) 구조 제공, 액세스 관리, 고속화, 안정성 향상 등이 있다.

#### 6. 장치 드라이버
- 디스크나 NIC 등의 물리 장치용 인터페이스를 제공.
- NIC나 디스크는 다수의 제조사가 독자 제품을 제공하고 있다. 각각에 대응하는 애플리케이션을 개발하는 것은 현실적이지 못하기 때문에 **커널은 장치 드라이버를 이용해서 그 아래에 있는 물리 장치를 은폐**한다.
- 각 장치 제조사가 OS에 대응하는 장치 드라이버를 제공해서 해당 OS의 표준 장치로서 커널을 경유해 이용할 수 있게 하는 것이다.


#### CF. 커널은 결코 견고하지 않다
커널 설계 및 구현 방식에는 크게 두 가지가 있다. 모놀리식(Monolithic)커널과 '마이크로(Micro)'커널이다. 

모놀리식은 '단일형'을 가리키고, 마이크로는 '작다'는 것을 의미한다.
모놀리식 커널은 os의 주요 구성요소를 모두 하나의 메모리 공간을 통해 제공한다.

명칭이 가진 의미대로 한 명의 '왕자'가 모든 기능을 제공하고 있는 형태다.

반면, 마이크로 커널에서는 최소한의 기능만 커널이 제공하고 그 외 기능은 커널 밖에서 제공한다. 커널 자체가 작아지기 때문에 더 심플하다고 할 수 있다. **전자의 대표적인 예가 유닉스 계열의 OS나 리눅스**이고, 후자의 대표적인 예로는 **애플의 맥 OS X**가 있다.

양쪽 다 장단점이 있기 때문에 현재 대부분의 아키텍처는 양쪽의 '장점'을 취하고 있다. 예를 들어, 리눅스에서는 커널 모듈을 이용해서 기능을 추가할 수 있기 때문에 마이크로 커널의 특징도 포함할 수 있다.

무엇이든 견고하기만 해서는 부족한 법이다. 

출처: 그림으로 보는 IT인프라 구조(제이펍)
