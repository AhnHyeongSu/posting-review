# 1. 용어 설명

1. 실행 단위 : cpu core에서 실행하는 하나의 단위, 프로세스가 될 수도 있고, 스레드가 될 수도 있다.
2. 프로그램 
   - OS위에서 실행할 수 있는 파일
   - 이 정적인 파일이 메모리에 올라가지 않은 상태, 코드 덩어리 형태
3. 프로세스 : OS위에서 **실행중인 프로그램**,  단일 스레드도 프로세스로 볼 수 있음
   - OS로부터 **독립적인 메모리 공간을 할당받음**

4. 프로세서 : 프로세스가 동작하는 hw (= CPU)

5. 동시성 : 하나의 CPU 코어에서 여러 프로세스(스레드)가 시분할로 번갈아면서 진행되지만, 동시에 진행되는 것처럼 보이는 것
6. 병렬처리 : 둘이상의 코어에서 동시에 여러 프로세스(스레드)가 한꺼번에 진행되는 것...

# 2. 프로세스 메모리 구조

- 프로그램이 동작할 때 필요한 CPU, 메모리, I/O 장치, 파일 등 자원을 할당 받은 후에 동작
- 프로그램이 메모리에 올라와 실행준비 or 실행중인 상태를 프로세스라고 한다.
- 프로그램이 메모리 공간에 로드되면 CPU가 명령어들을 순차적으로 처리

<img src="https://user-images.githubusercontent.com/38436013/129837664-4693d868-ab5b-4035-85b5-1fd47e5deee9.png" alt="image" style="zoom:80%;" />![image](https://user-images.githubusercontent.com/38436013/129839203-a96fcaef-fc9b-4b2c-ad8c-ba612729c25c.png)

**Code** : 코드 자체를 구성하는 메모리 영역 `실행 명령`
**Data** : 전역변수, 정적변수, 배열 등 `초기화된 데이터`
**Heap** : 동적 할당 시 사용 `new(), mallock() 등`
**Stack** : 지역변수, 매개변수, 리턴 값 `임시 메모리 영역`



**스택과 힙 영역이 구분된 이유**

컴파일 시 지역변수를 얼마나 사용할지 미리 계산할 수없기 때문에, 런타임에 지역변수 선언 순서에 따라 스택은 아래에서 위쪽으로 주소값을 주고, 힙영역은 위에서 아래쪽으로 주소값을 준다. 

스택의 포인터와 힙 포인터가 만나면 메모리가 소진되었다는 의미다.



# 3. 프로세스 구성 : PCB(Process Control Block)

- CPU가 여러 프로세스를 번갈아 실행하는 것을 Context Switching이라고 한다. 
- 이때, 어떤 프로세스를 어디까지 작업했는지를 알아야 한다. -> 주기억장치에서 정보 유지됨

- 따라서 `프로세스 생성 시`, 프로세스에 대한 정보를 담고 있는 `PCB 블럭이 함께 생성` 된다.

- PCB는 **프로세스를 제어하기 위한 정보 모음집**이다.

![image](https://user-images.githubusercontent.com/38436013/129839802-aab971b0-9f9c-4597-8baf-3e68d5d39ac2.png)

**포인터 (Pointer)** : 프로세스 상태 중 준비상태나 대기상태 큐 구현하기 위한 포인터

 **프로세스 상태 (Process State)** : 프로세스 현재 상태(new, ready, running, waiting, terminated)

**프로세스 번호 (PID, Process ID, Process Number)** : 프로세스 고유 ID

 **프로그램 카운터 (PC, Program Counter)** : **다음에 실행될 명령어의 주소** -> 프로세스가 어디까지 작업했는지 기억!!

**레지스터 (Register)** 

- 이전에 작업하던 내용
- 실행상태에서 다른 상태로 전이하는 경우, PC  정보를 레지스터에 저장(이 경우는 PC 레지스터라고 부르는 것 같다), 다음에 작업을 이어갈 때 복구시킨다.

 **메모리**

- 프로세스 주소 공간
- 가상주소와 실제주소의 mapping 정보도 포함

**프로세스 우선순위**

- 스케줄링 시 어떤 프로세스 선택할 지 결정

- 우선 순위, 최종 실행시각, CPU 점유시간 등 CPU 스케줄링 정보가 우선순위가 됨

### 정리

PCB는 프로세스 제어를 위한 정보 모음집이고, 프로세스 생성시에 만들어지며, 프로세스 상태 관리, 컨텍스트 스위칭을 위해서 반드시 필요하다.  프로그램 상태, 프로그램 카운터, 레지스터 정보는 기억하자.

# 4. 프로세스 상태

![image](https://user-images.githubusercontent.com/38436013/129845682-5982afbb-0e37-49d6-9f85-8c4557c1590a.png)

- OS가 프로세스에 임시적으로 있는 상태 : new, terminated

- OS가 프로세스를 실행 중인 상태 : running, waiting, ready



### running, waiting, ready

ready 은 실행 준비를 마친 상태

waiting 은 I/O이나 다른 이벤트가 발생하기를 기다리는 상태

running  -> waiting : 게임을 실행 시켜서 로그인을 해야 하는 상황에서 로그인은 아이디/비번 입력을 받아야 CPU는 로그인을 진행할 수 있다. I/O 인터럽트가 있을 동안 CPU는 기다려야 하므로 waiting 상태로 전이된다.

waiting -> ready : 아이디/비번 입력을 마치면 CPU는 다 기다렸으므로  ready로 상태를 전이한다.

ready -> running : CPU는 여러 프로세스 중 선택을 하는데, 이것을 스케줄링 이라고 한다. 이 작업을 dispatch 라고 부른다.



# 5. Context Switching

context란 CPU가 다루는 프로세스/스레드에 대한 정보

CPU는 하나의 프로세스 작업이 끝나면 다음 프로세스 작업을 진행하는데 이경우, 속도가 느리다. context switching을 이용하면 **여러 프로세스를 빠른 속도로 번갈아 가면서 실행**시킬 수 있고, **동시에 실행하는 것처럼 보여진다.** CPU를 효율적으로 사용하면서 빠른 속도로 작업을 처리한다. 이런 역할을 하기 위해 필요한 것이 `context switching`이다.

**Context Switching**은 현재 진행하고 있는 Task(프로세스/스레드)의 상태를 저장하고 다음 진행할 Task의 상태 값을 읽어 적용하는 과정

### 실행 순서

![image](https://user-images.githubusercontent.com/38436013/129893563-44b7bfd1-eb33-49f9-b2ca-00946aaaeb1d.png)
![image](https://user-images.githubusercontent.com/38436013/129893601-2bb18011-78a8-4d11-9edf-84c0315c4270.png)

프로세스1의 PCB1을 CPU에 적재->프로세스1 실행 -> 컨텍스트스위칭 -> 프로세스1의 PCB정보는 프로세스1의 레지스터에 저장 -> 프로세스1 대기 → 프로세스2 PCB2을 CPU에 적재 → 프로세스2 실행 → 이런식으로 진행

### 단점

컨텍스트 스위칭이 잦으면 `오버헤드가 발생`해서 성능이 떨어질 수 있다.

### 언제 발생?

1. I/O interrupt

2. CPU 사용시간 만료

3. 자식 프로세스 ForK

# 6. 멀티프로세스

- 부모 프로세스가 fork()를 하여 자식 프로세스를 여러 개 만들어 작업을 처리한다.

- 자식 프로세스는 부모와 별개의 독립적인 메모리 영역을 확보한다.

- ex) 한 어플리케이션에서 여러가지 일을 처리할 때

  - 여러 사용자가 로그인을 요청하는 상황이라면
  - 한 프로세스는 매번 하나의 로그인만 처리할 수 있으므로, 동시에 처리할 수 없다.
  - 그래서 부모 프로세스가 자식 프로세스를 만들어서 여러 요청을 처리

  ![image](https://user-images.githubusercontent.com/38436013/129854659-76f538ce-b05b-47f0-bdac-1f6855f4b623.png)

- 쉽게 말하면, 하나의 컴퓨터에 여러개의 CPU가 장착되어 하나 이상의 프로세스들을 동시에 처리(병렬 처리) 하는 개념이다.
- 장점
  - 독립된 구조이기 때문에 안전성이 높다.
  - 프로세스 중 하나의 프로세스에 문제가 생겨도, 다른 프로세스에는 영향을 주지 않는다.
- 단점
  - 독립된 구조이기 때문에 Context Switching으로 인한 오버헤드가 발생하여 성능저하가 발생한다.
  - 프로세스는 각각의 독립된 메모리 영역을 할당받기 때문에 따라서 다른 프로세스의 정보를 가져오려면 IPC(Inter-Process Communication)통신을 해야한다.



#### 프로세스는 스레드와 비교하면서 보는게 필요한데, 다음주에 스레드 공부 예정이라 그때 비교하여 정리해보겠습니다.!! 오늘은 프로세스만 

# 자문자답 QnA

### 컨텍스트 스위칭 비용은 프로세스와 스레드 중 어디가 더 클까?

 컨텍스트 스위칭 비용은 프로세스가 더 많이 든다. 스레드는 스택 영역을 제외한 모든 메모리를 공유하기 때문에 context switching 발생 시 스택 영역만 변경하면 되기 때문이다.

### 멀티 코어와 멀티 프로세스, 병렬 처리 용어

병렬 처리 : 여러 코어에서 동시에 하나 이상의 프로세스/스레드가 한꺼번에 진행되는 것

멀티 프로세스 : 여러 CPU를 통해 TASK(스레드/프로세스) 병렬 처리 (SW)

 멀티 코어 : 하나의 CPU에 코어가 여러개, TASK 병렬 처리 (HW)

멀티 코어와 멀티 프로세스에서 둘 다 병렬처리 라는 표현을 사용하는데, 구분이 잘 안되어서 찾아보았다. 멀티프로세스는 CPU가 여러개 이므로 코어도 여러개다. 여러개의 코어에서 task를 동시 처리하는 것이 병렬처리의 정의이므로, 멀티 프로세스는 병렬 처리를 한다고 볼 수 있을 것 같은데 맞겠지?

### context switching이 발생할 때, PC값을 레지스터에 보관, 그 이유는 ?

PC값은 스레드(프로세스)가 다음에 실행할 명령어를 말한다. 레지스터에 보관하는 이유는 CPU 스케줄링에 의해 실행 중이던 스레드/프로세스가 다른 스레드/프로세스에게 제어권이 넘어간다. 나중에 중지된 스레드/프로세스를 다시 실행하기 위해 PC(주소값)를 기억해야 한다. 따라서 PC 레지스터를 스레드마다 독립적으로 할당한다.

### 프로세스 메모리 구조는 코드, 데이터, 스택, 힙이 있다. 왜 이렇게 구역을 나눴을까?

결론부터 말하자면, 최대한 공유 가능한 데이터 공유하고, 메모리 사용량을 줄이기 위해서다.

코드 영역은 실행 코드이고, 같은 프로그램이라면 코드를 공유하므로 따로 관리한다.

DATA는 글로벌 변수 등이 있고, STACK은 지역변수나 리턴 값 등이 있다. 분리한 이유는 스택 구조의 특성과 전역 변수의 활용성을 위해서다.  전역 변수가 있는 DATA는 따로 지정하여 메모리를 아끼고, 함수와 지역변수가 있는 스택은 LIFO 스택 구조를 통해 실행된다.

### PCB 어떻게 관리될까?

링크드 리스트 방식으로 관리된다. PCB List Head에 PCB들이 생성될 때마다 붙게 된다. 주소값으로 연결이 이루어져 있는 연결리스트이기 때문에 삽입 삭제가 용이하다. 프로세스 생성되면 PCB 생성되듯이 프로세스 완료시 PCB도 제거된다.

### 스레드 공부하면 나중에 프로세스 VS 스레드 비교하기

## 참고

- https://aeroej.tistory.com/120

- https://jhnyang.tistory.com/7
- https://mfamcs.netlify.app/docs/CA_and_OS/%EC%BB%A8%ED%85%8D%EC%8A%A4%ED%8A%B8%20%EC%8A%A4%EC%9C%84%EC%B9%AD
- https://velog.io/@emily0_0/OS-Process-Thread

- https://www.youtube.com/watch?v=1grtWKqTn50
- https://velog.io/@emily0_0/OS-Process-Thread
- https://ybdeveloper.tistory.com/20