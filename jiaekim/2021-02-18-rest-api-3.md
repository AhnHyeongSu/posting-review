# [REST API의 이해와 설계] 3. REST API 보안 (1)

## REST API 보안

근래 대부분의 서비스들은 API를 기반으로 통신합니다. 앱과 서버 통신 또는 웹 클라이언트와 서비스 간 대부분의 통신이 이 API들을 이용해서 이루어지기 때문에 한번 보안이 뚫려 버리면 개인 정보 탈취뿐만 아니라 많은 문제를 일으킬 수 있습니다.

REST API 보안 관점들과 인증 인가에 어떤 방식이 있는지 자세히 알아봅시다.
해당 내용은 `조대협 서버사이드 대용량 아키텍처와 성능 튜닝` 책을 바탕으로 작성되었습니다.

보안 관련 내용이 많아 아래와 같이 나누어 포스팅할 에정입니다.
1. REST API 보안 (1) - REST API 보안 관점 5가지, 인증
2. REST API 보안 (2) - 인가, 자바스크립트 클라이언트 지원

### 1. REST API 보안 관점 5가지
#### 1.1 인증 (Authentication)
- `인증은 누가 서비스를 사용하는지 확인하는 절차`
- 쉽게 생각하면 로그인 시 사용자 아이디와 비밀번호를 넣어서 사용자를 확인하는 과정이 인증이다. API도 마찬가지로 API를 호출하는 대상 (단말이던 다른 서버이던 사용자이던)을 확인하는 절차가 필요하고 이를 `API 인증`이라고 한다.

#### 1.2 인가 (Authorizastion)
- `인가는 해당 리소스에 대해서 사용자가 그 리소스를 사용할 권한이 있는지 확인하는 권한 체크 과정`
- 예를 들어 /users라는 리소스가 있을 때 일반 사용자 권한으로는 내 사용자 정보만 볼 수 있지만, 관리자 권한으로는 다른 사용자 정보를 볼 수 있는 것과 같은 권한 차이이다.

#### 1.3 네트워크 레벨 암호화
- 인증과 인가 과정이 끝나서 API를 호출하게 되면 네트워크를 통해 데이터가 오가는데, 해커나 누군가 중간에서 이 네트워크 통신을 낚아채(감청) 데이터를 볼 수 없게 할 필요가 있다. 
- 이를 `네트워크 프로토콜단에서 처리하는 것을 네트워크 레벨의 암호화`라고 하는데, HTTP에서의 네트워크 레벨 암호화는 일반적으로 `HTTPS 기반의 보안 프로토콜을 사용`한다.

#### 1.4. 메시지 무결성 보장
- 메시지 무결성이란, `메시지가 해커와 같은 외부 요인에 의해 중간에 변조되지 않게 방지하는 것`
- 무결성을 보장하기 위해 많이 사용하는 방식은 메시지에 대한 `서명(Signature)`을 생성해서 메시지와 함께 보내고 검증하는 방식이 있다.
- 메시지 무결성의 경우 앞에서 언급한 네트워크 레벨의 암호화를 완벽하게 사용한다면 외부적인 요인(해커)에 의해서 메시지를 해석당할 염려가 없으므로 사용할 필요가 없다.

<details>
<summary>서명(Signature) 방식 예시</summary>
<div markdown="1">

1. 메시지 문자열이 있을 때 이 `문자열에 대한 해시코드`를 생성해서 문자열과 함께 보낸다.
2. 수신 쪽에서 받은 문자열과 이 `받은 문자열로 생성한 해시 코드`를 문자열과 함께 온 해시 코드와 비교한다.
3. 만약에 문자열이 중간에 변조되었으면 원래 문자열과 함께 전송된 해시 코드와 맞지 않기 때문에 메시지가 중간에 변조되었는지를 확인할 수 있다.

</div>
</details>

#### 1.5. 메시지 본문 암호화
- 네트워크 레벨의 암호화를 사용할 수 없거나, 또는 이를 신뢰할 수 없는 상황에는 추가로 `메시지 자체를 암호화 하는 방법`을 사용한다. 이는 어플리케이션 단에서 구현하는데 크게 두 가지 방법으로 접근할 수 있다.
    1. `전체 메시지를 암호화`하는 방법
        - 암호화에 드는 비용이 많을뿐더러 중간에 API Gateway 등을 통해서 메시지를 열어보고 메시지 기반으로 라우팅 변환 작업이 어렵다.
    2. `특정 필드만 암호화` 하는 방법
        - 일반적으로 전체 암호화보다 보안이 필요한 특정 필드만 암호화하는 방법을 사용한다.

### 2. 인증

API에 대한 인증(Authentication)은 여러 방법이 있으며 각 방식에 따라 보안 수준과 구현 난이도가 달라서 각 방식의 장단점을 이해하여 서비스 수준에 맞는 적절한 API 인증 방식을 선택해야 한다.

### 2.1 API 키 방식
가장 기초적인 방법이다. `API 키(Key)란 특정 사용자만 알 수 있는 일종의 문자열`이다. 
1. API를 사용하고자 할 때, 개발자는 API 제공사의 포탈 페이지 등에서 `API키를 발급`받는다.
2. API를 호출할 때 `API 키를 메시지 안에 넣어 호출`한다.
3. 서버는 메시지 안에서 API 키를 읽어 이 API가 `누가 호출한 API인지를 인증`한다.

모든 클라이언트가 같은 API 키를 공유하기 때문에 `한번 API 키가 노출되면 전체 API가 뚫려버리는 문제가 있으므로 높은 보안 인증이 필요할 때에는 권장되지 않는다.`

### 2.2 API 토큰 방식
`API 토큰(Token)을 발급`하는 방식은 ID, 비밀번호 등으로 `사용자를 인증한 후`에 그 사용자가 API 호출에 사용할 `기간이 유효한 API 토큰을 발급하여 API 토큰으로 사용자를 인증하는 방식`이다.

매번 API 호출 시 사용자 ID, 비밀번호를 보내지 않고 API 토큰을 사용하는 이유는 사용자 비밀번호는 주기적으로 바뀔 수 있고, 매번 네트워크를 통해 ID와 PW를 보내는 것은 보안상 사용자 계정 정보가 탈취당할 가능성이 크기 때문에 API 토큰을 별도로 발급해서 사용한다.

<img src = "https://user-images.githubusercontent.com/37948906/108165924-bf80e400-7136-11eb-9b52-ad8bcddc302c.png" width="600px">

이 인증 방식에는 다양한 변종이 있는데, 보안 수준에 따라 여러 방식을 사용할 수 있다.

#### 2.2.1 HTTP Basic Auth
가장 기본적이고 단순한 형태의 인증 방식이다. 사용자 ID와 비밀번호를 HTTP 헤더에 `Base64` 인코딩 형태(`Authorization: Basic VGvycnk6aGVsbG8gd29ybGQ=`)로 넣어 인증을 요청한다.

중간에 패킷을 가로채서 이 헤더를 Base64로 디코딩하면 사용자 ID와 비밀번호가 그대로 노출되기 때문에 반드시 HTTPS 프로토콜을 사용해야 한다.

#### 2.2.2 Digest Access Authentication
HTTP Basic Auth가 Base64 형태로 비밀번호를 실어서 보내는 단점을 보강하여 나온 인증 프로토콜로, 기본 원리는 `클라이언트가 인증을 요청할 때 클라이언트가 서버로부터 nonce라는 일종의 난수 값을 받고`(서버와 클라이언트는 이 난수 값을 서로 알고 있음), `사용자 ID와 비밀번호를 이 난수 값을 이용해서 해시화하여 서버로 전송`하는 방식이다.

이 경우 직접 ID와 비밀번호가 평문 형태로 날아가지 않기 때문에 해커가 중간에 비밀번호를 탈취할 수 없고, 설령 hash 알고리즘을 알고 있다고 하더라도 해시된 값에서 반대로 비밀번호를 추출하기가 어려워서 Basic Auth 방식보다 향상된 보안을 제공한다.

<details>
<summary>Digest Access Authentication 방식 자세히 보기</summary>
<div markdown="1">

![rest_api_3_digest_access_auth](https://user-images.githubusercontent.com/37948906/108168239-4edbc680-713a-11eb-9d0e-e5534c60d7d8.png)

1. 클라이언트가 서버에 특정 리소스 /study/index.html을 요청한다.
2. 서버는 해당 세션에 대한 nonce값을 생성하여 저장하고, 클라이언트에 반환한다. 이때 realm을 같이 반환하는데 realm 은 인증의 범위로, 예를 들어 하나의 웹 서버에 study.war, user.war가 각각 http://myweb/study와 http://mywep/user로 배포되었을 때, 각각의 어플리케이션은 서로 다른 realm을 가진다.
    > 해당 세션에 대해 nonce 값을 유지 저장해야하기 때문에 서버 쪽에서는 상태 유지에 대한 부담이 생긴다. HTTP 세션을 사용하거나 또는 서버 간에 공유 메모리(Memcached나 Redis 등)를 넣어서 서버 간에 상태 정보를 유지할 수 있는 설계가 필요하다.

3. 클라이언트는 앞에서 서버로부터 받은 realm과 nonce 값으로 해시 값을 생성하는데, 다음을 통해서 응답 해시 값을 생성한다.
    - 해시 값을 생성하는 자세한 내용은 [참고링크](https://feel5ny.github.io/2019/11/24/HTTP_013_01/)를 참고하자.
    - 이 때 해시 값을 MD5를 사용하고 있는데, 이는 보안 레벨이 낮아서 FIPS 인증 요건에서 인정하고 있지 않다. 따라서 최소 SHA-1, SHA1-244, SHA1-256 이상의 해시 알고리즘을 사용하기를 권하고 있다고 책에 나와있지만 2016년에 SHA-1 인증서 발행이 중단된 것으로 알고 있기 때문에 최소 SHA-2 256이상을 사용하기를 권장한다. (현재 SHA-3까지 나왔다.)

4. 서버는 먼저 3에서 전달된 nonce 값이 이 세션을 위해서 서버에 저장된 nonce 값과 같은지 비교를 한 후, 전달된 사용자 이름인 terry와 nonce 값 그리고 서버에 저장된 사용자 비밀번호를 이용해서 3번과 같은 방식으로 응답 해시 값을 계산해서 클라이언트에서 전달한 해시 값과 같은지를 비교하고 같으면 해당 리소스(/study/index.html)을 반환한다.

</div>
</details>

#### 2.2.3 클라이언트 인증 추가
추가적인 보안 강화를 위하여 사용자 인증 뿐만 아니라, `클라이언트 인증 방식`을 추가할 수 있다. `페이스북은 API 토큰을 발급받도록 사용자 ID, 비밀번호뿐만 아니라 App ID와 App Secret이라는 것을 같이 입력`받도록 하는데, App ID는 특정 앱에 대한 등록 ID이고 App Secret은 특정 앱에 대한 비밀번호로, 페이스북 개발자 포털에서 앱을 등록하면 앱 별로 발급되는 일종의 비밀번호이다.

<img src="https://user-images.githubusercontent.com/37948906/108170949-26ee6200-713e-11eb-9484-8b30a1e20f62.png" width="600px">

API 토큰을 발급받을 때, App Id와 App Secret을 이용하여 `클라이언트 앱을 인증하고 사용자 ID와 비밀번호를 추가로 받아서 사용자를 인증하여 API 액세스 토큰을 발급`한다.

#### 2.2.4 제 3자 인증 방식 (OAuth 2.0 Authorization grant type)

`제 3자 인증 방식(OAuth)`은 페이스북이나 구글과 같은 API 서비스 제공자들이 파트너 애플리케이션에 많이 적용하는 방법으로, 만약 내가 My Server Application이라는 서비스를 페이스북 계정을 이용하여 인증하는 경우이다.

이때 중요한 점은 서비스 My Server Application에 대해서 해당 사용자가 페이스북 사용자임을 인증해주지만, 서비스 My Server applicaiton은 사용자 비밀번호를 받지 않고 페이스북이 사용자를 인증하고 서비스 My Server Application에 알려주는 방식이다. 즉, `파트너 서비스에는 페이스북 사용자의 비밀번호가 노출되지 않는다.`

<details>
<summary>제 3자 인증 방식 흐름 세부 정보</summary>
<div markdown="1">

#### 페이스북 제 3자 인증 방식 API Token 요청 흐름
1. 먼저 페이스북의 개발자 포털에서, 페이스북 인증을 사용하고자 하는 `어플리케이션 정보를 등록`한다. (서비스명, 서비스 URL, 인증이 성공했을 때 인증 성공 정보를 받을 콜백 URL)
2. 페이스북 개발자 포털은 등록된 정보를 기준으로 해당 어플리케이션에 대한 c`lient_id와 client_secret을 발급`한다. 이 값은 앞에서 설명한 `클라이언트 인증에 사용`된다.
3. 다음으로 개발하고자 하는 어플리케이션에 이 client_id와 clinet_secret 등을 넣고, 페이스북 인증 페이지 정보를 넣어서 어플리케이션을 개발한다.

#### 제 3자 인증 방식을 이용한 API 인증 흐름

<img src = "https://user-images.githubusercontent.com/37948906/108310084-16012780-71f6-11eb-9a11-62c214029594.png" width="600px">


1. 웹 브라우저에서 사용자가 My Server Application 서비스에 접근하려고 요청한다.
2. My Server Application은 사용자의 인증이 되어 있지 않기 때문에 페이스북 로그인 페이지 URL을 HTTP 리다이렉션으로 브라우저에 보낸다. 이때 이 URL에 페이스북에 이 로그인 요청이 My Server Application에 대한 사용자 인증 요청임을 알려주고자 client_id 등의 추가 정보와 함께 페이스북의 정보 접근 권한(사용자 정보, 그룹 정보 등)을 scope라는 필드를 통해서 요청한다.
3. 브라우저는 페이스북 로그인 페이지로 이동하여 2단계에서 받은 추가적인 정보와 함께 로그인을 요청한다.
4. 페이스북은 사용자에게 로그인 창을 보낸다.
5. 사용자는 로그인 창에 ID/비밀번호를 입력한다.
6. 페이스북은 사용자를 인증하고 인증 관련 정보와 함께 브라우저로 전달하면서 My Server Application 로그인 완료 페이지로 리다이렉션을 요청한다.
7. My Server Application은 6에서 온 인증 관련 정보를 받는다.
8. My Server Application은 이 정보를 가지고 페이스북에 이 사용자가 제대로 인증을 받은 사용자인지를 문의한다.
9. 페이스북은 해당 정보를 보고 제대로 인증된 사용자임을 확인해주고 API Access Token을 발급한다.
10. My Server Application은 9에서 받은 API Access Token으로 페이스북 API 서비스에 접근한다.

이러한 방식은 자사가 아닌 파트너 서비스에서 자사 서비스 사용자의 인증을 거쳐서 API의 접근 권한을 전달하는 방식이다. 이러한 인증 방식의 대표적인 구현체는 OAuth2.0으로, 이와 같은 제 3자 인증뿐만 아니라 직접 자사의 어플리케이션을 인증해서 클라이언트로부터 직접 ID/비밀번호를 입력받는 등 클라이언트 타입(웹, 서버, 모바일 어플리케이션)에 대한 다양한 시나리오를 제공한다.

이러한 3자 인증 방식은 일반적인 서비스에서는 필요하지 않지만, 자사의 API를 파트너 등 외부 시스템에 제공하면서 사용자의 ID/비밀번호를 보호하는데 필요한 서비스이기 때문에 API를 외부에 적용할 때에는 고려해야 한다.

</div>
</details>

#### 2.2.5 IP 화이트 리스트를 이용한 터널링

만약에 API를 호출하는 클라이언트의 API가 일정하다면 사용할 수 있는 손쉬운 방법인데, 서버 간의 통신이나 타사 서버와 자사 서버 간의 통신 같은 경우에 API 서버는 `특정 API URL에 대해서 들어오는 IP 주소를 화이트 리스트로 유지하는 방법`이 있다.

`API 서버 앞단에 HAProxy나 아파치와 같은 웹 서버를 배치하여서 특정 URL로 들어올 수 있는 IP 목록을 제한`하거나 아니면 전체 API가 특정 서버와의 통신에만 사용된다면 아예 `하드웨어 방화벽 자체에 들어올 수 있는 IP 목록을 제한`할 수 있다. 설정만으로 가능한 방법이기 때문에 `서버 간의 통신이 있을 때 적용할 것을 권장`한다.

#### 2.2.4 Bi-diretional Certification (Mutual SSL)
가장 높은 수준의 인증 방식을 제공할 수 있는 개념이다. 보통은 HTTPS 통신을 사용할 때 서버에 공인 인증서를 높고 단방향으로 SSL을 제공하는데, `Bi-directional Certification(양방향 인증서 방식) 방식은 클라이언트에도 인증서를 높고 양방향으로 SSL을 제공하면서 API 호출에 대한 인증을 클라이언트의 인증서를 이용하는 방식`이다.

구현 방법이 가장 복잡한 방식이긴 하지만, 공인 기관에서 발행된 인증서를 사용한다면 API를 호출하는 쪽의 신원을 확실하게 할 수 있고 메세지까지 암호화되기 때문에 가장 높은 수준의 인증을 제공한다. 이런 인증 방식은 일반 서비스에서는 사용되지 않으며 `높은 인증 수준을 제공하는 몇몇 서비스나 특정 서버 간 통신에 사용`하는 것이 좋다.


### 2.3 JWT 방식

근래에 들어서 Claim 기반의 토큰 방식인 `JWT(JSON Web Token)`가 많이 사용되고 있다.
REST API에 대한 보안과 인증이 화두가 되면서 많이 언급되는 것이 Oauth인데 근래에 떠오르는 것이 `JWT 표준`이다.

#### Claim 기반 토큰의 개념

- `OAuth에 의해서 발급되는 access_token은 랜덤 문자열로, 토큰 자체에 특별한 정보를 가지고 있지 않은 일반적인 스트링 형태`이다.
- `API나 서비스를 제공하는 서버의 입장에서 그 access_token을 통해서 사용자와 연관된 권한을 구별하여 이를 허용해주는 구조`이다. 즉, 서비스를 제공하는 입장에서는 토큰을 가지고 그 토큰과 연관된 정보를 서버쪽에서 찾아야 한다. (사용자 ID나 권한 등) 
- JWT는 Claim 기반이라는 방식을 사용하는데 `Claim이라는 사용자에 대한 프로퍼티나 속성`을 말한다. 토큰 자체가 정보를 가지는 방식인데, `JWT는 이 Claim을 JSON을 이용해서 정의`한다.

다음은 Claim을 JSON으로 서술한 예이다. 이 `JSON 자체를 토큰으로 사용하는 것이 Claim 기반의 토큰 방식`이다.

```
{
    "id":"terry",
    "role":["admin","user"],
    "company":"pepsi"
}
```

이러한 Claim 방식의 토큰은 무엇이 좋을까? 이 토큰을 이용해서 요청을 받는 서버나 서비스 입장에서는 이 `서비스를 호출한 사용자에 대한 추가 정보는 이미 토큰 안에 다 들어가 있기 때문에 다른 곳에서 가져올 필요가 없다.`

예를 들어, '사용자 관리'라는 API 서비스가 있다고 가정하자. 이 API는 '관리자(admin)' 권한을 가진 사용자만이 접근할 수 있으며, '관리자'권한을 가진 사용자는 그 관리자가 속해 있는 '회사(Company)'의 사용자 정보만 관리할 수 있다고 정의하자. 이 시나리오에 대해서 일반적인 스트링 기반의 토큰과 JWT와 같은 Claim 기반의 토큰이 어떤 차이를 보이는지 알아보도록 하자.

#### OAuth 토큰의 경우

<img src = "https://user-images.githubusercontent.com/37948906/108320708-82842280-7206-11eb-847d-81448e070e77.png" width="700px">

#### Claim 기반의 토큰을 이용한 API 권한 인증의 경우

<img src = "https://user-images.githubusercontent.com/37948906/108321064-fc1c1080-7206-11eb-8812-981817fa333a.png" width="500px">

결과적으로 차이점은 `토큰을 생성하는 단계에서는 생성된 토큰을 별도로 서버에서 유지할 필요가 없으며 토큰을 사용하는 API 서버 입장에서는 API 요청을 검증하기 위해서 토큰을 가지고 사용자 정보를 별도로 계정 시스템 등에서 조회할 필요가 없다.`

JWT는 이 `JSON Claim을 Base64로 인코딩하여 HTTP 헤더에 쉽게 넣을 수 있으며, JSON 기반이기 때문에 파싱과 사용이 쉽다.` 결과적으로 Claim 기반의 토큰은 토큰 자체가 정보를 담음으로써 토큰으로 서비스나 API 접근을 제어할 때 별도의 작업이 서버에서 필요하지 않으며, 토큰 자체를 서버에서 관리할 필요가 없어서 구현이 상대적으로 단순해진다.

<details>
<summary>JWT 구성</summary>
<div markdown="1">

### JWT 구성

#### 1. Payload(정보)의 Claim 정의
JWT는 Claim을 JSON 형태로 표현하는 것인데, JSON은 '\n'등 줄바꿈 문자가 있기 때문에 REST API 호출 시 HTTP 헤더 등에 넣기가 매우 불편하다. 그래서 `JWT에서는 이 Claim JSON 문자열을 Base64 인코딩을 통해서 하나의 문자열로 변환`한다.
**JSON 기반의 Claim 예제**
```
{
    "id":"terry",
    "role":["admin","user"],
    "company":"pepsi"
}
```
**JSON 기반 Claim 예제를 Base64 인코딩한 결과**
```
ewogICAgImlkIjoidGVycnkiLAogICAgInJvbGUiOlsiYWRtaW4iLCJ1c2VyIl0sCiAgICAiY29tcGFueSI6InBlcHNpIgp9
```

#### 2. Header(헤더) 정의 - 서명 생성 방식

그러면 무결성 보장을 위해서 사용할 수 있는 알고리즘이 SHA2-256 HMAC 뿐일까? 보안 요건에 따라서 SHA2-256, 354, 512, 그리고 공인 인증서를 이용한 RS256 등 다양한 서명 방식을 지원한다. 그럼다면 JWT 토큰이 어떤 방식으로 서명되어있는지 어떻게 알 수 있을까?

이를 위해 `JWT 토큰의 맨 앞부분에는 서명에 어떤 알고리즘을 사용했는지를 JSON 형태로 정의한 후 Base64 방식으로 인코딩한 문자열을 붙인다.`

#### 3. Signature(서명) 정의
그렇다면 위 Claim 기반 토큰을 받은 후 누군가가 토큰을 변조해서 사용하면 어떻게 막을 수 있을까? 이렇게 메세지가 변조되지 않았음을 증명하는 것이 무결성(Integrity)이라고 하는데, `무결성을 보장하는 방법 중 많이 사용되는 것이 서명(Signature)이나 HMAC을 사용`하는 방식이다.

- `HAMC 방식`
    - `원본 메세지에서 해시 값을 추출하고, 이를 비밀 키를 이용해서 복호화시켜서 토큰 뒤에 붙인다.`
    - 누군가가 메시지를 변조하고서 새롭게 HMAC 값을 만들어내려고 해도 HMAC의 앞의 비밀 키를 이용해서 복호화되었기 때문에 그 비밀키를 알 수 없는 이상 HMAC을 만들어 낼 수 없다.
    - 그래서 앞의 JSON 메시지에 대해 SHA-256 알고리즘을 이용하여 비밀키를 'secret'이라고 하고 HMAC을 생성하면 결과는 다음과 같다.
**HMAC을 정의하는 방법**
```
HMACSHA256(
  base64UrlEncode(header) + "." +
  base64UrlEncode(payload),
  secret)
```

**JSON 기반 Claim에 대해서 SHA1-256으로 생성한 HMAC**
```
1f4a02c3ac59d82b13741c4f0da1993857d2d215c3e74a21db42ae19e31955dc
```

**JSON으로 서명 생성 방식은 SHA2-256으로 정의한 예**
```
{"alg":"HS256", "typ":"JWT"}
```

**JSON 문자열을 Base64 인코딩한 결과**
```
eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9
```

#### 4. 전체 메시지 포맷
위에서 설명한 서명 방식, JSON 기반의 Claim, 서명(Signature)까지 포함한 전체적인 JWT 토큰의 구조를 보면 다음과 같다.
```
{서명 방식을 정의한 JSON을 Base64 인코딩}.{JSON Claim을 Base64 인코딩}.{"JSON Claim에 대한 서명}
```

완성된 [jwt.io](https://jwt.io/) 사이트에서 확인해보면 아래와 같다.

![캡처](https://user-images.githubusercontent.com/37948906/108576411-e6226300-7360-11eb-97e1-ab32d326a678.PNG)


</div>
</details>


### JWT의 문제점

#### 1. 길이
`Claim에 넣는 데이터가 많아질수록 JWT 토큰의 길이가 길어진다.` API 호출에 사용할 시에 호출마다 헤더에 붙어서 가야 하기 때문에 길이가 길다는 것은 그만큼 네트워크 대역폭 낭비가 심하다는 뜻이다.

#### 2. 한번 발급된 토큰은 값을 수정하거나 폐기가 불가
`JWT 토큰 내에 모든 정보를 다 가지고 있기 때문에 한번 발급된 토큰에 대한 변경은 서버에서는 더는 불가능`하다. 예를 들어 토큰을 잘못 발행해서 삭제하고 싶더라도 서명만 맞으면 맞는 토큰으로 인식하기 때문에 서버에서는 한번 발급된 토큰의 정보를 바꾸는 일이 불가능하다.

그래서 만약에 `JWT를 쓴다면 만료 시간(Expired time)을 꼭 명시적으로 두도록 하고 Refresh Token 등을 이용해서 중간마다 토큰을 재발행`하도록 해야 한다.

#### 3. 암호화
`JWT는 기본적으로 Claim에 대한 정보를 암호화하지 않는다. 단순히 Base64로 인코딩만 하기 때문에 중간에 패킷을 가로채거나 기타 방법으로 토큰을 취득했으면 토큰 내부 정보를 통해서 사용자 정보가 누출될 가능성`이 있다. 특히 자바스크립트 기반의 웹 클라이언트는 브라우저의 디버거를 통해서 토큰이 노출될 수 있다. 이를 보완하는 방법으로 토큰 자체를 암호화 하는 방법이 있다. JSON을 암호화하기 위한 스펙으로는 JWE(JSON Web Encryption)가 있다.


---

## 관련 자료 링크
- [[REST API의 이해와 설계] 1. REST API 란?](https://github.com/jiaekim123/posting-review/blob/master/jiaekim/2021-02-04-rest-api-1.md)
- [[REST API의 이해와 설계] 2. REST API 디자인 가이드](https://github.com/jiaekim123/posting-review/blob/master/jiaekim/2021-02-11-rest-api-2.md)
- [[REST API의 이해와 설계] 3. REST API 보안](https://github.com/jiaekim123/posting-review/blob/master/jiaekim/2021-02-18-rest-api-3.md)

---

## 참고 자료
- [조대협의 서버사이드] 대용량 아키텍처와 성능 튜닝
- [마이크로소프트 API Guideline](https://github.com/microsoft/api-guidelines/blob/vNext/Guidelines.md#74-supported-methods)
- [Rest API WIKI](https://en.wikipedia.org/wiki/Representational_state_transfer)