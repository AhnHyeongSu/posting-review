# [REST API의 이해와 설계] 3. REST API 보안 (2)

## REST API 보안

근래 대부분의 서비스들은 API를 기반으로 통신합니다. 앱과 서버 통신 또는 웹 클라이언트와 서비스간 대부분의 통신이 이 API들을 이용해서 이루어지기 때문에 한번 보안이 뚫려 버리면 개인 정보 탈취 뿐만 아니라 많은 문제를 일으킬 수 있습니다.

REST API 보안 관점들과 인증 인가에 어떤 방식이 있는지 자세히 알아봅시다.
해당 내용은 `조대협 서버사이드 대용량 아키텍처와 성능 튜닝` 책을 바탕으로 작성되었습니다.

보안 관련 내용이 많아 아래와 같이 나누어 포스팅하였고 이번엔 보안의 두 번째, 인가와 자바스크립트 클라이언트 지원 관련 내용입니다.

1. REST API 보안 (1) - REST API 보안 관점 5가지, 인증
2. REST API 보안 (2) - 인가, 자바스크립트 클라이언트 지원

### 3. 인가
- 인증과정이 끝나면 권한에 대한 인증, 즉 인가(Authorization) 과정이 필요하다. 사용자가 인증을 받고 로그인을 했더라도 해당 API를 호출할 수 있는 권한이 있는가를 확인해야 한다.

#### 3.1 API 인가 방식
##### 3.1.1 RBAC (Role Based Access Control) 방식
가장 일반적인 권한 인증 방식으로 사용자의 역할(Role)을 기반으로 하는 `RBAC(Role Based Access Control)`이라는 방식이 있다. 이 방식은 정해진 역할에 권한을 연결해놓고, 이 역할을 가진 사용자에 해당 권한을 부여하는 것이다.

예를 들어 아래와 같은 권한을 만들고, Terry에 '마스터 관리자' 역할을 부여하면 해당 역할에 대한 권한을 가지게 된다.
- 일반 관리자: 사용자 관리, 게시물 관리, 회원 가입 승인
- 마스터 관리자: 카페 게시판 관리, 메뉴 관리, 사용자 관리, 게시물 관리, 회원가입 승인

이렇게 `권한 부여의 대상이 되는 사용자나 그룹`을 `Object`라고 하고 `개별 권한`을 `Permission`이라고 정의하며 `사용자의 역할`을 `Role`이라고 정의한다. 
RBAC은 이 Role에 권한을 매핑한 다음 Object에 이 Role을 부여하는 방식으로, 많은 권한 인가는 사용자 역할을 기반으로 하기 때문에 사용하기가 쉽다.

<img src=https://user-images.githubusercontent.com/37948906/109147510-6ead6300-77a8-11eb-9b30-e99673769723.png width=500px>

##### 3.1.2 ACL (Access Control List) 방식
RBAC방식이 권한을 Role이라는 중간 매개체를 통해 사용자에게 부여하는데 반해서, ACL 방식은 사용자(또는 그룹과 같은 권한의 부여 대상)에게 직접 권한을 부여하는 방식이다.

사용자 Terry에게 직접 사용자 관리, 게시판 관리, 회원가입 승인 권한을 부여하는 방식이 대표적인 ACL의 예이다.

<img src=https://user-images.githubusercontent.com/37948906/109147753-baf8a300-77a8-11eb-9b08-0b31cd27990d.png width=400px>

이러한 권한 검증을 이용하여 API Acces Token으로 사용자를 찾고 사용자에게 할당된 역할이나 Access Control을 받아서 API 인증을 처리할 수 있다.

#### 3.2 API 권한 인가 처리 위치

API에 대한 권한 인가 처리는 여러 가지 계층에서 처리할 수 있다. 
1. API를 호출하는 쪽인 클라이언트
2. API를 실행하는 API 서버
3. API의 중간 길목 역할을 하는 게이트웨이

보통 위와 같은 계층에서 인가 처리를 하며, 근래에는 API 서버에서 처리하는 것이 가장 일반적이다.

##### 3.2.1 클라이언트에 의한 API 권한 인가 처리
이 방식은 클라이언트가 신뢰할 수 있는 경우에만 사용할 수 있다. 이 방식은 기존에 웹 UX 로직이 서버에 배치된 형태(스프링 MVC와 같은 웹 레이어가 있는 경우)에 주로 사용했다. 
웹 어플리케이션에서 사용자 로그인 정보(세션 정보와 같은)를 보고 사용자 권한을 조회하고 API를 호출하는 방식이다.

<img src=https://user-images.githubusercontent.com/37948906/109151287-4ecc6e00-77ad-11eb-96bf-b818e7ecee67.png width=500px>

예를 들어 모바일 클라이언트는 일반 사용자만 사용한다고 가정하고 웹 어플리케이션은 일반 사용자와 관리자 모두 사용한다고 가정했을 때 모바일을 위한 API server를 별도로 배치하고 사용자 인증만 되면 모든 API 호출을 허용하도록 하고, 웹 어플리케이션만 API 권한 인가 처리를 하게 할 수 있다.

##### 3.2.2 게이트웨이에 의한 권한 인가 처리
이러한 권한 인가는 모바일 클라이언트, 자바스크립트 기반의 웹 클라이언트 등 다양한 클라이언트가 지원됨에 따라 점차 서버 쪽으로 이동하기 시작했는데, 특히 자바 스크립트 클라이언트는 클라이언트에 대한 권한 인가가 의미가 없어서 어쩔 수 없이 서버 쪽에서 권한 인가를 처리할 수밖에 없다.

만약 자바스크립트에 권한 인가 로직을 넣을 경우 브라우저의 디버거로 코드 수정이 가능하기 때문에 권한 처리 로직을 우회할 수도 있고, 또한 API 포맷만 안다면 직접 API를 서버로 호출해서 권한 인가 없이 API를 사용할 수도 있다.

서버에서 권한을 처리하는 방법은 API 호출 길목인 게이트웨이나 API 비즈니스 로직 두 군데서 처리할 수 있다. API Gateway에 의한 권한 처리는 구현이 쉽지 않기 때문에 API 서버에서 권한 처리를 하는 것이 일반적이다.

<img src=https://user-images.githubusercontent.com/37948906/109152624-17f75780-77af-11eb-9483-923526fb71ad.png width=500px>

API Gateway에서 인가 처리를 할 경우 인증 정보가 HTTP Header나 Body, JSON 등에 들어가 있는 경우 일일이 메시지 포맷에 따라 별도의 권한 통제 로직을 게이트웨이 단에서 구현해야 하기 때문에 오버로드가 발생하여 공통 필드 등으로 API 권한처리를 하지 않을 때에는 사용하기 어렵다.

##### 3.2.3 서버에 의한 API 권한 인가 처리

그래서 가장 일반적이고 보편적인 방법은 API 요청을 처리하는 API 서버의 비즈니스 로직 단에서 권한 처리를 하는 방식이다. 이 방식은 앞에서 언급한 API Gateway 방식과 비교했을 때 각 비즈니스 로직에서 API 메세지를 각각 파싱하기 때문에 API 별로 권한 인가 로직을 구현하기 용이하다.

<img src=https://user-images.githubusercontent.com/37948906/109153202-efbc2880-77af-11eb-99d5-d367ea2e8897.png width=550px>

이 경우에는 권한 인가에 필요한 필드들을 API Gateway에서 변환해서 API 서버로 전달해줌으로써 구현을 간단하게 할 수 있는데, 다음과 같이 API 클라이언트가 API Access Token을 이용해서 API를 호출했을 경우 API Gateway가 이 Access Token을 권한 인가에 필요한 사용자 ID, Role 등으로 변환해서 API 서버에 전달해주게 되면 각 비즈니스 로직은 API 권한 인가에 필요한 사용자 정보를 별도의 데이터베이스에서 찾지 않고도 이 헤더의 내용만을 이용해서 API 권한 인가 처리를 할 수 있게 된다.

#### 3.3 네트워크(전송) 레벨 암호화

가장 기본적이고 필수적인 REST API 보안 방법은 네트워크 전송 프로토콜에서 HTTPS 보안 프로토콜을 사용하는 방법이다. HTTPS 프로토콜만 사용한다 하더라도 메시지 자체를 암호화해서 전송하기 때문에 해킹으로 말미암은 메시지 누출 위협을 해소할 수 있다.

그러나 HTTPS를 사용하더라도 메세지를 낚아채거나 변조하는 방법이 있는데, 이러한 해킹 방법을 중간자 공격(Man-in-The-Middle-Attack)이라고 한다. 아래는 정상적인 HTTPS 통신을 했을 때의 동작이다. 서버에서 제공하는 인증서를 이용하여 API 클라이언트와 서버 상호 간에 암호화된 신뢰할 수 있는 새로운 네트워크 연결을 만든다.
##### [HTTPS를 이용한 네트워크 SSL 암호화 방식]
<img src=https://user-images.githubusercontent.com/37948906/109154210-53932100-77b1-11eb-8bb2-f1d5242efff6.png width=400px>

##### [중간자 공격을 이용한 인증서 바꿔치기]
<img src=https://user-images.githubusercontent.com/37948906/109154467-a8cf3280-77b1-11eb-9b22-747c8b2937e1.png width=500px>

중간자 공격의 경우 신뢰할 수 있는 연결을 만들려고 할 때 해커가 API 클라이언트와 서버 사이에 끼어들어 인증서를 바꿔쳐서 중간 연결을 가로챈다. 이렇게 해커는 중간에서 API 클라이언트와 서버 사이에 메세지를 모두 열어보고 변조도 가능해진다.

이런 중간자 공격을 방지하기 위해서 여러 가지 방식이 있지만, 가장 손쉬운 방법은 공인된 인증서(CA)를 사용하고 인증서를 확인하는 것이다. 공인 인증서는 기관에서 인증서를 발급한 사람이 누구인가에 대한 신원 정보를 가지고 있기 때문에 이 서명을 확인하여 인증서가 변조되었는지 확인할 수 있다.

#### 3.4 메시지 본문 암호화
다음으로는 간단하게 암호화가 필요한 특정 필드만 애플리케이션 단에서 암호화하여 보내는 방법이 있다. 메세지를 암호화하여 통신하려면 클라이언트와 서버가 암호화 키를 가져야 하는데, 암호화 키는 크게 `대칭 키`와 `비대칭 키 알고리즘` 두 가지가 있다.

##### 3.4.1 비대칭 알고리즘
- 암호화를 하는 키와 암호를 푸는 복호화 키가 다른 경우
- 암호화하는 키를 공개키(Public Key)라고 하고 암호화를 푸는 키를 비밀 키(Private Key)라고 한다. 이 공개 키는 암호화할 수 있지만, 반대로 암호화된 메시지를 풀 수가 없으므로 누출이 되어도 안전하다.
- 처음 클라이언트가 서버에 인증이 되었을 때 클라이언트에게 이 공개 키를 내리고, 이후 메시지를 이 공개 키를 통해서 암호화를 하게 되면 암호화된 메시지는 비밀키를 가진 서버만이 풀 수 있어서 안전하게 서버로 메시지를 보낼 수 있다.
- 대표적인 비대칭 키 알고리즘: RSA

##### 3.4.2 대칭 알고리즘
- 암호화와 복호화 키가 같은 알고리즘
- API 클라이언트와 서버가 같은 키를 알고 있어야 한다.
- 키를 네트워크를 통해서 보내면 중간에 해커에 의해서 낚아채일 염려가 있기 때문에 양쪽에 안전하게 키를 전송하는 방법이 필요하다.
    <details>
    <summary>안전하게 대칭 알고리즘을 사용한 키를 전달하는 방법</summary>
    <div markdown="1">

    ```
    1. 서버에서 공개 키 KA1와 비공개 키 KA2쌍을 생성한다.
    2. 클라이언트에게 공개 키 KA을 네트워크를 통해서 내려 보낸다.
    3. 클라이언트는 새로운 비공개 대칭 키 KB를 생성하고 KA1을 이용해서 암호화하여 서버로 전송한다.
    4. 서버는 전송된 암호화 메세지를 KA2로 복호화하여 그 안에 있는 비공개 키 KB를 꺼낸다.
    5. 향후 클라이언트와 서버는 상호 API 통신 시 비공개 대칭 키 KB를 이용하여 암호화와 복호화를 진행한다.
    ```

    </div>
    </details>
- 대표적인 대칭 키 알고리즘: AES, DES


#### 3.5 메시지 무결성 보장
무결성이란 서버에서 API 호출을 받았을 때 이 호출이 신뢰할 수 있는 호출인지 아닌지를 구별하는 방법을 말한다. 즉 해커가 중간에 메세지를 가로채고 나서 내용을 변조하여 서버에 보냈을 때 내용이 변조되었는지를 판단하는 방법인데, 일반적으로 HMAC을 이용한 방식이 널리 사용된다. 
<details>
<summary>HMAC의 작동 원리 (궁금한 사람만 보시오)</summary>
<div markdown="1">

정리중..

</div>
</details>

### 4. 자바 스크립트 클라이언트 지원

자바스크립트 기술이 발전하면서 SPA(Single Page Applicatino)가 유행하기 시작했다. SPA란 브라우저에서 페이지 간의 이동 없이 자바스크립트를 이용해서 동적으로 페이지를 변경할 수 있는 방식이다.

페이지를 다시 읽지 않으므로 반응이 좋아서 많이 사용되는데, SPA의 경우 서버와의 통신을 자바스크립트가 직접 XMLHttpRequest 객체를 이용해서 API 호출을 바로 하는 형태이다. 이러한 변화는 API 보안 부분에서도 새로운 요구사항을 불러왔는데, 이는 자바스크립트 클라이언트는 기존의 모바일이나 웹 어플리케이션, 서버 등과 다른 기술적인 특성이 있기 때문이다.

자바스크립트 클라이언트는 코드 자체가 노출된다. 자바스크립트 코드는 브라우저로 로딩해서 수행하기 대문에 사용자 또는 해커가 클라이언트 코드를 볼 수 있다. 그래서 보안 로직이 들어있어도 로직 자체는 탈취당할 수 있다. 아울러 자바스크립트는 실행 중에 브라우저의 디버거를 이용해서 변숫값을 보는 것, 또는 변숫 값을 변경하거나 비즈니스 로직을 변경하는 등의 행위가 가능하다. 그래서 일반적인 API 보안과는 다른 접근이 필요하다.

#### 4.1 동일 출처 정책에 대한 처리
먼저 자바스크립트의 API에 대한 호출은 `동일 출처 정책(Same Origin Policy)`의 제약을 받는다. `동일 출처 정책이란 자바스크립트와 같이 웹 브라우저에서 동작하는 프로그래밍 언어에서 웹 브라우저에서 동작하는 프로그램은 해당 프로그램이 로딩된 위치에 있는 리소스만 접근할 수 있다는 정책`이다.

다음 그림과 같이 웹 사이트 sitea.com에서 자바스크립트를 로딩한 후에 이 스크립트에서 api.my.com에 있는 API를 XMLHttpRequest를 통해서 호출하고자 하면 동일 출처 정책에 의해서 호출 에러가 난다.

<img src=https://user-images.githubusercontent.com/37948906/109157303-306a7080-77b5-11eb-989d-2081038f44c3.png width=400px>


이를 해결하는 방법으로는 인프라 측면에서 프록시를 사용하는 방법이나 JSONP와 CORS(Cross Origin Resource Sharing)라는 방법이 있다.

#### 4.2 프록시를 이용하는 방식
프록시를 이용하는 방식은 간단하다. 동일 출처 정책의 문제는 API 서버와 자바스크립트가 호스팅되는 서버의 URL이 달라서 문제가 발생하게 된다. 이를 앞단에 Reverse Proxy를 넣어서 전체 URL을 같게 만들어주면 된다.

<img src=https://user-images.githubusercontent.com/37948906/109165607-159cf980-77bf-11eb-902c-6b4f3efed908.png width=400px>

이러한 구조가 되면, 자바스크립트가 로딩된 사이트도 mysite.com이 되고, 자바스크립트에서 호출하고자 하는 API URL도 mysite.com이 되기 때문에 동일 출처 정책에 위배되지 않는다.

이 방식은 단순하지만, 자사의 웹 사이트를 서비스 하는 경우에만 가능하다. (타사의 사이트를 Reverse Proxy 뒤에 놓기는 쉽지 않기 때문에) 그래서 자사의 서비스용 API를 만드는데는 괜찮지만 파트너사나 일반 개발자에게 자바스크립트용 REST API를 공개하는 경우에는 적절하지 않다.

#### 4.3 특정 사이트에 대한 접근 허용 방식
CORS 방식 중 이 방식은 가장 간단하고 쉬운 방식으로, API 서버의 설정에서 모든 소스에서 들어오는 API 호출을 허용하도록 하는 것이다. api.my.com이라는 API 서비스를 제공할 때 이 API를 어느 사이트에서라도 자바스크립트로 호출할 수 있게 하는 것이다.

이는 HTTP로 API를 호출하였을 때 HTTP 요청에 응답을 주면서 HTTP 헤더에 Request Origin(요청을 처리해줄 수 있는 출처)을 명시하는 방식이다.

api.my.com에서 응답 헤더에 다음과 같이 명시해주면 sitea.com에 의해서 로딩된 자바스크립트 클라이언트 요청에 대해서만 api.my.com가 처리해준다.

> Access-Control-Allow-Origin: sitea.com

만약에 다음과 같이 *로 해주면 Request Origin에 관련 없이 사이트에서 로딩된 자바스크립트 요청에 대해서 처리해준다.

> Access-Control-Allow-Origin: *

#### 4.4 Pre-flight를 이용한 세세한 CORS 통제
REST 리소스(URL)당 섬세한 CORS 통제가 필요한 경우에는 Pre-flight 호출이라는 것을 이용할 수 있다. 이 방식에서는 REST 리소스를 호출하기 전에 웹 브라우저가 HTTP OPTIONS 요청을 보내면 해당 REST 리소스에 대해서 가능한 CORS 정보를 보내준다. (접근이 허용된 사이트, 젒근이 허용된 메서드 등)

웹 브라우저에서는 XMLHttpRequest를 특정 URL로 요청하기 전에 먼저 HTTP OPTIONS를 호출한다. 그러면 서버는 해당 URL에 접근할 수 있는 Orign URL과 HTTP 메서드를 반환해준다. 이를 Pre-flight 호출이라고 하는데, 이 정보를 기반으로 브라우저는 해당 URL에 XMLHttpRequest를 보낼 수 있다.

<details>
<summary>자세히 보기</summary>
<div>

정리중

</div>
</details>

#### 4.5 자바스크립트 클라이언트를 위한 API Access Token에 대한 인증 처리

앞서서 언급하였듯이 자바스크립트 클라이언트는 모바일 앱이나 서버와 같은 다른 API 클라이언트와 비교해서 API Access Token을 안전하게 저장할 방법이 없으므로 이 API Access Token에 대해서 추가 관리 방식이 필요하다. 몇 가지 추가적인 방식을 사용하는데 내용은 다음과 같다.

##### 4.5.1 API Access Toekn을 보안 쿠키를 통해서 주고 받는다
API Access Token을 서버에서 발급하여 자바스크립트 클라이언트로 반환할 때, HTTP 보디에 반환하는 것이 아니라 보안 쿠키(Secure Cookie)에 넣어서 반환한다.

보안 쿠키는 일반 HTTP 프로토콜을 통해서는 전송할 수 없고 항상 HTTPS를 통해서만 가능하다. 같은 API 서버로도 일단 HTTP 호출을 할 경우 API Access Token이 쿠키를 통해서 전달되지 않기 때문에 네트워크를 통해서 Access Token을 탈취하는 것은 불가능하다.

여기에 HTTP_ONLY라는 옵션을 쿠키에 추가하는데, 이 옵션을 적용하게 되면 쿠키를 자바스크립틀르 통해서 읽거나 조작할 수 없다. 단지 브라우저가 서버로 요청을 보낼 때, 브라우저에 의해서 자동으로 쿠키가 전송된다.

이 두가지를 쓰면 최소한 자바스크립트 소스 코드 분석이나 네트워크 프로토콜 감청을 통한 API Access Token을 방어할 수 있다.

##### 4.5.2 API Access Token은 해당 세션에서만 유효하도록 한다

여기에 몇 가지 방어 기재를 추가하도록 하는데, 마치 HTTP 세션과 같이 특정 IP와 시간 내에서만 API Access Token이 유효하도록 하는 방식이다. Access Token을 발급할 때 Access Token을 요청한 클라이언트의 IP와 클라이언트의 Origin을 같이 저장해두고 발급할 때 만료시간(Expire Time)을 정해둔다. (예: 약 20분)

다음 Access Token을 이용해서 API가 호출될 때마다 IP와 Origin을 확인하고, Access Token이 유효시간(Expire time)내이면 이 유효시간을 다시 연장해준다. (+20분을 다시 추가)

<details>
<summary>자세히 보기</summary>
<div>

정리중

</div>
</details>


---

## 관련 자료 링크
- [[REST API의 이해와 설계] 1. REST API 란?](https://github.com/jiaekim123/posting-review/blob/master/jiaekim/2021-02-04-rest-api-1.md)
- [[REST API의 이해와 설계] 2. REST API 디자인 가이드](https://github.com/jiaekim123/posting-review/blob/master/jiaekim/2021-02-11-rest-api-2.md)
- [[REST API의 이해와 설계] 3. REST API 보안](https://github.com/jiaekim123/posting-review/blob/master/jiaekim/2021-02-18-rest-api-3.md)

---

## 참고 자료
- [조대협의 서버사이드] 대용량 아키텍처와 성능 튜닝
- [마이크로소프트 API Guideline](https://github.com/microsoft/api-guidelines/blob/vNext/Guidelines.md#74-supported-methods)
- [Rest API WIKI](https://en.wikipedia.org/wiki/Representational_state_transfer)