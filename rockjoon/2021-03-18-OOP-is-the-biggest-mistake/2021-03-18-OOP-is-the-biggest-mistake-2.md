# 객체지향 프로그래밍은 컴퓨터 과학의 최대 실수이다. - 2

## 예측 가능성에 대해


우리는 자동차의 엑셀을 밟을 때 차가 가속되길 기대한다.  그리고 브레이크를 밟을 때 차가 멈추길 기대한다.  
설사 100억 분의 1이더라도 이를 벗어나서는 안된다. 
```
We also want software to be reliable.
But that is not enough, software is expected to be predictable.
```
> 우리는 소프트웨어가 신뢰할만하길 바란다.
하지만 그것만으로 충분하지 않다. 소프트웨어는 예측가능해야 한다.

## 결정적(Determinism) & 비결정적(Nondeterminism)

결정적 함수는 **같은 입력값에 대해 항상 같은 결과값을 반환하는 함수**를 뜻한다. 마치 수학의 함수와 같다.  
비결정적 함수는 이와 반대된다. 같은 입력값에 대해 같은 결과값이 보장되지 않는다.

무엇이 결정론적 함수를 만들까?

외부의 상태에 의존하지 않는 함수는 결정적이다.  
결정적 함수만을 호출하는 함수는 결정적 함수이다.

따라서 외부의 상태에 의존하지 않더라도 `Math.random()`과 같은 비결정적 함수를 호출한다면 이는 결정적 함수가 아니다.

비결정적 함수는 예측가능하지 않다. 뿐만 아니라 소프트웨어의 버그를 만들어 낸다. 버그는 개발자가 소중한 시간을 디버깅에  
소모되게 하고, 사용자의 사용성을 떨어뜨린다.

## 순수 함수

순수 함수는 결정적(determinism)이면서도 사이드 이펙트(side effect)가 없는 함수를 뜻한다.  

순수 함수의 장점은 무엇일까? 순수 함수는 예측 가능하다. 이는 테스트를 매우 쉽게 만든다.  
함수에 대해 추론하는 것이 매우 쉬워진다. OOP와 다르게, 애플리케이션 전반에 대한 상태(state)를 신경 쓸 필요가 없다.  
당신은 오직 현재의 함수에만 집중하면 된다.

동시성에도 강점이 있다. 상태(state)가 공유되지 않기 때문이다.  리팩토링도 쉽다. 단지 함수를 복사하고 이동시키기만 하면 된다.

## 만병통치약(silber bullet)은 있습니다.

이 우울한 소프트웨어의 실패 속에 한줄기의 희망이 있다. 대부분의 문제를 해결 만병통치약, 이는 바로 **수학**이다.

우리에게는 수세기 동안에 걸쳐 수많은 똑똑한 사람들이 이뤄왔던 수학이 있다.

현대의 과학이 **비결정적이고 예측불가능한 토대** 위에 세워져 있다면 어떻게 될까? 우리는 중세시대로 돌아가게 될 것이다.  
오늘날의 소프트웨어 산업도 OOP라는 위태로운 토대 위에 세워져 있다. 

## 단단한 기반

소프트웨어에도 수학만큼 의지할 수 있는 것이 있을까? 대답은 yes이다.  
많은 수학 개념들이 프로그래밍에 고스란히 도입되었다. 바로 `함수형 프로그래밍`이다.

함수형 프로그래밍은 **프로그래밍의 수학**이다.  굳건하고 단단하다.  
함수형 프로그래밍은 순수 함수가 모여 만들어 진다. 순수 함수는 예측 가능하기 때문에 함수형 프로그래밍 또한 예측가능하다.  
함수형 프로그래밍은 버그가 없을까? 그렇지 않다. 하지만 그 버그 조차 결정적이고 예측가능하다.  
같은 입력값에 대해 언제나 같은 버그를 도출할 것이다.

## 잠깐, 그렇다면 스파게티 코드는?

OOP에는 최고의 용법(best practice)이 있다. "상속 대신 컴포지션을 사용하라"와 같은 것들 말이다.  
이러한 용법들은 이론적으로 스파게티 코드를 막을 수 있다. 하지만 **용법은 용법**일 뿐이다. 아무것도 이를 **강제**할 수 없다.

함수형 프로그래밍은 패러다임 자체로 이를 강제한다. 예를 들어 컴포지션은 함수형 프로그래밍에서는 **유일한 방법**이다.
큰 함수는 작은 함수들의 컴포지션(구성)으로 이루어져있다.

## OOP와 FP는 보완적 관계라구!

실망시켜서 유감이지만, 이 둘은 보완적 관계가 아니다.

FP의 함수는 순수하다. OOP는 그렇지 않다.  
FP는 결정적이고 따라서 예측 가능하다. OOP는 비결정적이고 예측불가능하다.  
컴포지션은 FP에서 자연스럽다. OOP에서는 그렇지 않다.  
OOP는 스파게티 코드를 유발한다. FP는 예측가능하고 유지가능한 코드를 만든다.  
OOP 프로그래머는 대부분의 시간을 버그를 고치는데 시간을 허비한다. FP프로그래머는 대부분의 시간을 결과를 도출하는데 사용한다.


## 이제는 액션을 취해야 할 때

가까운 미래에 OOP는 COBOL과 같은 "공룡" 취급을 받게 될 것이다.  C++와 자바는 죽을 것이다.  
함수형 프로그래밍을 시작하라. 
