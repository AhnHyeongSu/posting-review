# 클라이언트 식별과 쿠키

## 클라이언트 식별

HTTP protocol의 연결을 지속하지 않고(connectionless), 상태를 저장하지 않는(stateless) 속성때문에 클라이언트를 확인하기 어렵다. 따라서 클라이언트 식별을 위한 여러가지 방법을 사용한다.

### 클라이언트 IP 기반 식별

예전에는 클라이언트 식별을 위해 ip주소를 저장해서 식별하려고 했다.

#### 하지만,

- 클라이언트 IP 주소는 사용자가 아니라 컴퓨터 기준으로 발급된다. 따라서 같은 컴퓨터를 여러명이 사용한다면 유저를 식별할 수 없다.
- 많은 인터넷 서비스 제공자(ISP)는 동적으로 IP주소를 할당하고, 동적인 IP주소를 가지므로 유저 식별이 불가능하다.
- NAT 방화벽을 통해 인터넷을 사용하는 경우 IP주소를 식별할 수 없다.
- proxy server를 사용하면, proxy server의 IP를 바라보게 된다. 클라이언트 IP가 아니라!

이런 이유로 이제는 클라이언트 식별을 위해 이 방법은 거의 사용하지 않는다!

### 사용자 로그인

소심하게 유저의 클라이언트 IP를 받으려고 하는 것보다 더 능동적으로 사용자를 식별할 수 있는 방식이 있다. 유저에게 사용자이름과 비밀번호를 통해 인증할 것을 요구하여 명시적으로 식별 요청을 할 수 있다. 이를 통해 로그인 정보를 서버요청시마다 보내줘서 사용자를 식별하고, 개인화된 서비스를 제공할 수 있다.

### 뚱뚱한 URL (FAT URL)

사용자의 URL마다 식별번호나 상태정보를 URL뒤에 붙여서 사용자를 추적하는 기술이다. 사용자가 웹사이트에 처음 로그인하면 유일한 ID가 생성되고, 이후 URL에 추가되어 사용자 아이디와 관련된 추가 정보를 통해 모든 하이퍼링크를 뚱뚱한 URL로 바꾼다. 서버통신하는 HTTP 트랜잭션을 하나의 클러스터로 묶는 용도로 사용한다.

#### 하지만,

- 브라우저에 노출되는 뚱뚱한 URL은 새로운 사용자들에게 혼란을 줄 수 있다.
- URL을 공유하면 나의 정보도 같이 공유되어버린다!
- 캐시를 사용할 수가 없다! (URL이 달라지니까!)
- 서버 부하가 가중된다 (뚱뚱한 URL을 위한 HTML 페이지를 따로 그려야하니까)
- 사용자가 링크를 타고 다른 사이트로 이동하거나 의도치않게 이탈하게 되면, `뚱뚱한 상태`에서 벗어나게 된다. 그럼 유저 상태가 초기화되어버린다.
- 사용자가 뚱뚱한 URL을 저장해뒀다 활용하지 않는 이상, 로그아웃하면 모든 정보를 잃어버린다.



## 쿠키

쿠키는 키 - 값 형태를 가진다. 현재 가장 많이 사용하는 방식이다. 세션을 유지하기 위해 저장해두는 값이다. 웹사이트는 쿠키활용을 위해 사용자에게 아래와 같은 허락 알림을 띄우기도 한다.

![image](https://user-images.githubusercontent.com/45934061/115852544-28e8e000-a463-11eb-93de-2ccddc411c90.png)

쿠키는 브라우저가 서버 관련 정보를 저장하고, 사용자가 해당 서버에 접근할 때마다 그 정보를 함께 전송하게 해서 서버가 유저를 식별할 수 있게 하는데에 목표가 있다.

### 타입과 동작

#### 쿠키 타입

쿠키는 세션쿠키(session cookie)와 지속쿠키(persistent cookie) 두가지로 나뉜다.
**세션쿠키**는 주로 사용자가 사이트를 사용하는 동안 관련 설정이나 유저 선호를 저장하기 위해 사용한다. 사용자가 브라우저를 닫으면 삭제된다.
**지속쿠키**는 사용자가 주기적으로 방문하는 사이트에 대한 설정 정보나 유저정보를 유지하려고 사용한다. 디스크에 저장되어 브라우저를 닫거나 컴퓨터를 재시작하더라도 남아있다.

세션쿠키의 discard prameter가 설정되어있거나, expires, max-age 파라미터가 존재하지 않으면 세션쿠키는 지속쿠키가 된다.

#### 쿠키의 동작

1. 맨 처음 유저가 사이트에 방문한다. 서버는 해당 유저를 다음번 방문부터 식별하기로 마음먹는다.
2. 유저만을 위한 유일한 값을 만들고, Set-Cookie 혹은 Set-Cookie2라는 HTTP 응답헤더에 적어서 클라이언트에게 던져준다.
3. 브라우저는 해당 헤더값을 읽어서 쿠키 콘텐츠를 쿠키 데이터베이스에 저장한다.
4. 혹시나 유저가 다시 돌아온다면, 브라우저는 쿠키콘텐츠를 쿠키 요청 헤더에 적어서 서버에게 준다.



### 쿠키는 사이트마다 다르다.

각 브라우저는 각기 다른 방식으로 쿠키를 저장한다. 브라우저는 여러개의 쿠키를 가지지만, 모든 쿠키를 모든 사이트에 보내지는 않는다.

- 쿠키를 모두 전달하면 성능이 크게 저하되고
- 서버에 특화된 이름과 값을 포함하고 있기 때문에 대부분의 서버는 다른 도메인의 쿠키를 이해하지 못한다.
- 모든 사이트에 쿠키 전체를 전달한다면, 어떤 사이트가 어떤 정보를 갈취해 갈 지 모른다는 위험이 있다.

보통 브라우저는 쿠키를 생성한 서버(도메인이 같은 서버)에게만 쿠키에 담긴 정보를 전달한다.

도메인만 설정되어있다면, 도메인이 같으면 해당 쿠키를 전달하고, path까지 설정되어있다면 해당 path를 가져야만 해당 쿠키를 전달한다. 쿠키는 일종의 상태정보이고, 서버가 생성하여 클라이언트에 전달하고, 클라이언트가 다시 `유효한 서버`에게 전달하는 하나의 흐름이다.

#### Google Chrome Cookies

크롬은 cookies라는 SQLite 파일에 쿠키를 저장한다. 총 13개의 필드를 가진다.

- name : 키
- value : 값

- domain

  쿠키의 도메인을 말한다. (ex, `www.google.com`, `example.com`)

- path

  쿠키의 패스, (ex, `/`, `/login`)

- Expires / Max-Age

  쿠키의 만료일 또는 최대 사용기간, 세션쿠키의 경위 이 값은 항상 `Session`이라는 값을 가진다.

- size

  쿠키의 바이트사이즈를 말한다.

- HTTP

  boolean, 이 쿠키가 HTTP 통신을 통해서만 사용되어야 하고, JavaScript 수정이 허용되지 않음을 의미한다.

- secure

  boolean, 이 쿠키가 HTTPS 통신을 통해서만 사용될 수 있음을 의미한다.

- SameSite

  `strict`, `lax`. CSRF 공격을 방지하기 위해 사용하는 속성, `lax` 로 설정되어 있으면, 동일한 사이트 내 요청과 다른 사이트의 GET 요청을 전송한다. `strict`로 설정되어 있다면, 크로스사이트 요청을 허용하지 않는다.
  `None`이 원래 defaul 값이었지만, `lax` 로 20년 2월 4일 릴리즈된 chrome 80 버전부터 lax값으로 변경됐다.

- Priority

  `low`, `medium`(default), `high` 값 중 하나. 쿠키가 도메인별 쿠키용량을 초과해버려 삭제되어버리는 것을 막기 위해 우선순위를 할당하는 것이다.



### Safari Cookies

safari도 비슷하게 `name`, `value`, `domain`, `path`, `expired`, `size`, `secure`, `HttpOnly`, `SameSite` 필드를 가진다.



### Cookie 명세

#### version 0

version 0는 쿠키를 최초로 사용한 netscape가 정의했다.

- Set-Cookie 헤더
  ```
  Set-Cookie: name=value [; expires=date] [;path=path] [;domain=domain] [; secure]
  ```
  
  | 속성       | 설명                                                         |
  | ---------- | ------------------------------------------------------------ |
  | name=value | `required`. name, value 모두 큰 따옴표로 감싸지 않은 세미콜론, 쉼표, 등호, 공백을 포함하지 않는 문자열.<br />     *Set-Cookie: A=B* |
  | Expires    | `optional`. cookie lifetime을 날짜 포맷 문자열로 지정한다. 이 기간이 지나면 해당 쿠키는 삭제되고, 전달되지 않는다. GMT 기준으로 날짜 요소간 구분자는 dash(`-`) 를 활용하여 명시한다. expires가 명시되지 않으면, 사용자 세션이 끝날때 파기된다.<br />    *expires=Wednesday, 09-Nov-99 23:12:40 GMT* |
  | Domain     | `optional`. 서버가 특정 도메인에만 쿠키를 제한적으로 전달하게 하기 위해 사용한다. 명시된 도메인에 해당하는 도메인만 쿠키를 설정할 수 있고, 2~3개의 영역을 기술하는 도메인을 기술하게 되어있다.(`.or` 말고 `edu.or` 처럼 기술하란 이야기) 명시된 도메인은 매칭하는 문자열의 접미사로 활용한다.<br />    *domain="edu.or"* |
  | Path       | `optional`. 이 속성으로 서버에 있는 특정 문서에만 쿠키를 할당할 수 있다. path속성에 기술된 값이 URL경로의 앞부분과 일치하면 쿠키를 전달한다. 명시하지 않으면, 해당 헤더를 전달하는 URL의 경로가 사용된다.<br />    *path=/optional* |
  | Secure     | `optional`. 이 속성이 존재하면 HTTP가 SSL 보안연결을 사용할 때만 쿠키를 전송한다. <br />    *secure* |

- Cookie

  ```
  Cookie: name=value; name=value [; ...]
  ```

  서버에 domain, path, secure 필터가 현재 요청하려고 하는 모든 사이트에 들어맞으면서 아직 만료되지 않은 쿠키들을 함께 보낸다. 모든 쿠키는 쿠키헤더에 한데 이어붙여 보낸다.

#### version 1

쿠키의 확장버전인 version 1은 RFC2965 문서에서 정의한다. (이전 버전인 version 0은 RFC 2109에 정리해서 규격화시키려했으나, 사실상 실패한다.) version 0을 규격화하고, 새로운 기능을 추가하여 version 1을 발표했으나, 제대로 꽃을 피워보기도 전에 RFC 6265가 나타나면서 사망했다. version 0와 크게 차이나는 속성만 알아보자.

- Set-Cookie2

  | 속성       | 설명                                                         |
  | ---------- | ------------------------------------------------------------ |
  | Version    | `required`. 쿠키 명세의 버전을 가르키는 말.                  |
  | Comment    | `optional`. 서버가 쿠키를 사용하려는 의도를 저장한다. UTF-8로 인코딩 된 값. |
  | CommentURL | `optional`. 쿠키를 사용하는 목적과 정책에 대해 기술된 웹페이지 URL을 저장한다. |
  | Discard    | `optional`. 이 속성이 기술되어 있으면 클라이언트 프로그램이 종료될때 쿠키를 삭제한다. |

- Cookies

  쿠키값과 현재의 웹사이트에 들어맞는 필터정보에 달러(`$`)표시를 붙여서 쿠키와 함께 전송한다.

#### RFC6265

![image](https://user-images.githubusercontent.com/45934061/115868526-8dae3580-a477-11eb-80a5-08f49fb25f52.png)

기본 틀은 version 0와 비슷하다. 

- version 속성을 명시하지않고(version 1의 호환때문에 제안되어 사용되었던 항목), 
- Set-Cookie2 헤더를 더 이상 사용하지 않는다.(Set-cookie 헤더만 사용한다.) 
- max-age 값이 존재할 경우 expire값을 무시한다.
- path 속성을 신뢰하지 않는다.









##### REFERENCE

- 
- [Chrome Developers : chrome.cookies](https://developer.chrome.com/docs/extensions/reference/cookies/)
- [RFC6265](https://tools.ietf.org/html/rfc6265)
- 

