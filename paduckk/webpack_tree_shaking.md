# 블로그

### 서론

리액트 웹 앱을 개발 한다면 주로 사용 되는 도구가 `webpack`일 것입니다. `webpack`의 주 역할은 js, css 등등 여러 모듈화 된 소스 파일을 번들링 해주어 배포에 용이하게 해줍니다.

이 과정 중에서 소스 코드들을 최적화 하여 번들의 용량을 작게 해주기도 합니다. 소스 코드의 양을 줄이는 최적화에는 크게 두가지가 있습니다.  코드 자체를 압축하는 방식(`minify`)와 소스 코드 중 사용하지 않는 코드를 버리는 (`treeShaking`) 두가지 방식이 있습니다.

### Minify

`minify`는 내가 작성한 소스 코드의 의미를 알아 볼 수 없지만 동작은 동일하게 하도록 바꾸어 줍니다.

`webpack`에서는 기본적으로 production mode로 번들링하게 되면 `[terser](https://github.com/terser/terser)` 를 이용하여 압축합니다

어떻게 `terser`플러그인이 소스 코드를 최적화 하는지 아래 예시를 통해 확인 할 수 있습니다.

- 최적화 전

    ```jsx
    var x = {
        baz_: 0,
        foo_: 1,
        calc: function() {
            return this.foo_ + this.baz_;
        }
    };
    x.bar_ = 2;
    x["baz_"] = 3;
    console.log(x.calc());
    ```

- 최적화 후

    ```jsx
    var x={o:(0,3),t:1,i:function(){return this.t+this.o},s:2};console.log(x.i());
    ```

동작은 동일하게 하지만 소스 코드의 파일의 용량은 크게 줄었을 것입니다.

### TreeShaking

`treeShaking`은 라이브러리의 소스 코드 중 내가 사용한 부분만 import 해주어 번들에 포함되고 나머지 사용하지 않는 코드는 버려주는 매우 훌륭한 마법 같은 기능입니다. 

`webpack`을 소개 해주는 자료들에서 이 기능을 소개해주는 것을 보았을 때 정말 좋은 세상에서 개발하고 있구나 생각을 했습니다.

하지만..

직접 프로젝트의 번들링 최적화를 해보면서 역시나 세상은 만만치 않구나 라는 것을 알게 되었고 `TreeShaking`에는 많은 제약 조건이 있다는 것을 알게 되었습니다.

### 첫 번째 제약 조건 모듈 시스템

JS에 여러 모듈 시스템이 존재 하지만 주로 `commonJS`, `ES modules` 두가지 방식이 주를 이루고 있습니다.

- `commonJS`는 `const lodash = require('lodash')` 처럼 require 문을 사용해 모듈을 불러오고 **nodeJS**에서 지원하는 모듈 시스템 이기도 합니다.
- `ES modules`는 `import lodash from 'lodash'` import 문을 사용해 모듈을 불러옵니다.

`webpack`에선 `Treeshaking`을 하기 위한 조건으로 `ES modules`로 빌드 된 소스 코드만 지원 합니다.

한마디로 내가 npm을 통해 어떤 라이브러리를 받았을때 해당 라이브러리가 `ES module`로 빌드 되어 있어야 `treeShaking`을 통해 최적화가 이루어집니다. 

하지만 대다수의 npm 라이브러리들은 기본적으로 `nodeJS`에서 동작이 되게 배포 하므로 `ES modules`이 아닌 `commonJS`로 빌드 되어 배포 되어져 있어 아쉽게도 거의 **트리 쉐이킹을 통한 최적화는 이루어지지 않습니다**.

그렇다고 방법이 없는 것은 아닙니다. 

일부 유명 라이브러리의 경우 위와 같은 이유로 ES 모듈로 빌드 된 버전을 따로 배포 하기도 합니다.

`lodash`, `lodash-es` 둘 다 같은 라이브러리 이지만 빌드 된 모듈 시스템만 다르게 하여 배포 됩니다. `webpack`을 사용 한다면 최적화를 위해 `lodash-es` 를 받아서 사용 할 수도 있겠습니다.

또 다른 방법은 차후 설명 드리겠습니다.

### 두 번째 제약 조건 코드간의 의존성 sideEffects

`sideEffects` 옵션은 직접 내가 만든 패키지를 다른 개발 환경에서 트리쉐이킹이 되도록 최적화 하여 개발 하겠다면 도움이 되는 내용이지만 외부 라이브러리들을 최적화와는 무관한 내용이므로 직접 만드시는 상황이 아니면 넘어 가셔도 괜찮습니다.

내가 직접 프론트엔드에서 사용 할  공통 모듈을 개발하는데 `treeShaking`을 통해 최적화 되도록 한다면 위의 첫번째 제약 조건에 나온 것 처럼 `ES modules`로 빌드하여 배포하여야 합니다. 또 한가지 중요한 옵션인 `sideEffects`가 있습니다.

`sideEffects` 옵션은 `webpack`에서 설정하는 것이 아닌 배포되는 패키지의 `package.json`에 정의 해주는 옵션입니다. 기본 값은 `true`로 되어 있습니다. 이 옵션은 패키지 개발자가 `webpack`에게 사용한 코드 이외의 코드는 제거해도 문제가 없는지 알려주는 옵션입니다. 

만약 import 한 코드를 제외하고 전부 제거해도 괜찮으려면 각 코드간에 의존성 관리에 문제가 없어야 합니다. 

예를 들어 `A`라는 외부 패키지에서  `a`, `b`, `c` 라는 함수가 존재 할 때 `a` 함수만 import 해서 사용 할 경우

```jsx
// A pacakge

export const a = () => { ... }
export const b = () => { ... }
export const c = () => { ... }
```

```jsx
// index.js

import { a } from 'A'

a()
```

`webpack` `treeShaking`을 통해 `b` 와 `c`는 삭제 될 거 라고 기대 할 수 있습니다. 

하지만 만약 `a` 함수 내에서 `b`나 `c`에 의존성을 가지고 있다면 `b`와 `c`가 삭제 되었을 때 부작용이 발생하게 됩니다.

이러한 의존 관계를 번들링 과정에서 파싱하여 일일히 가려내기 어려우므로 이 패키지를 개발한 개발자에게 선택권을 줍니다. 번들링 과정중 import 한 코드를 제외한 나머지를 제거하더라도 문제가 되지 않는지 설정 하는 옵션이 `sideEffects`입니다.

### 또 다른 최적화 방법

(토요일전까지 써보겟습니다 ㅜㅜ)

### 번들링 최적화를 위해 시간을 투자한다면

번들링 최적화를 하기 위해 여러모로 삽질 해보고 실험 해본 결과는 이렇습니다.

외부 라이브러리에 다수 의존하는 경우엔 `treeShaking`을 통해 최적화는 다소 효과가 미비합니다.

외부 모듈을 최적화를 염두 해두고 뜯어서 다시 개발하지 않는 이상 `webpack`을 프로덕션 모드로 번들링 한다면 이미 어느정도 할만큼 최적화가 되었다고 볼 수 있기 때문입니다.

내가 만든 모듈이 아니라면 `treeShaking`보다는 다른 최적화 방안을 고려 해 보는게 좋습니다. (SSR, code splitting 등등)

하지만 `moment`, `antd` 등등 거대한 외부 패키지들은 가이드 문서에 최적화 방안을 제시하여 줍니다.

따라서 기억해야 할 중요한 요소는 다음과 같습니다.

- 용량이 크고 꼭 사용하여야 하는 패키지는 문서에 최적화 가이드가 있는지 확인 해본다.
- 다운 받으려는 패키지의 디펜던시가 많은지 적은지 확인한다. 적을 수록 좋다
- 굳이 필요하지 않으면 받지 않는다.
- [https://bundlephobia.com/](https://bundlephobia.com/)를 잘 활용 해보자.

이상입니다. 긴 글 읽어주셔서 감사합니다.